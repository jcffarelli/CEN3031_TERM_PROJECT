{"mappings":"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","sources":["<anon>","public/map/js/data.ts","node_modules/kd-tree-javascript/kdTree.js","public/map/js/projection.js","public/map/js/wind.ts"],"sourcesContent":["var $2a714b91454b8405$exports = {};\n/**\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */ (function(root, factory) {\n    if (typeof define === 'function' && define.amd) define([\n        'exports'\n    ], factory);\n    else factory($2a714b91454b8405$exports);\n})($2a714b91454b8405$exports, function(exports1) {\n    function Node(obj, dimension, parent) {\n        this.obj = obj;\n        this.left = null;\n        this.right = null;\n        this.parent = parent;\n        this.dimension = dimension;\n    }\n    function kdTree(points, metric, dimensions) {\n        var self = this;\n        function buildTree(points, depth, parent) {\n            var dim = depth % dimensions.length, median, node;\n            if (points.length === 0) return null;\n            if (points.length === 1) return new Node(points[0], dim, parent);\n            points.sort(function(a, b) {\n                return a[dimensions[dim]] - b[dimensions[dim]];\n            });\n            median = Math.floor(points.length / 2);\n            node = new Node(points[median], dim, parent);\n            node.left = buildTree(points.slice(0, median), depth + 1, node);\n            node.right = buildTree(points.slice(median + 1), depth + 1, node);\n            return node;\n        }\n        // Reloads a serialied tree\n        function loadTree(data) {\n            // Just need to restore the `parent` parameter\n            self.root = data;\n            function restoreParent(root) {\n                if (root.left) {\n                    root.left.parent = root;\n                    restoreParent(root.left);\n                }\n                if (root.right) {\n                    root.right.parent = root;\n                    restoreParent(root.right);\n                }\n            }\n            restoreParent(self.root);\n        }\n        // If points is not an array, assume we're loading a pre-built tree\n        if (!Array.isArray(points)) loadTree(points, metric, dimensions);\n        else this.root = buildTree(points, 0, null);\n        // Convert to a JSON serializable structure; this just requires removing\n        // the `parent` property\n        this.toJSON = function(src) {\n            if (!src) src = this.root;\n            var dest = new Node(src.obj, src.dimension, null);\n            if (src.left) dest.left = self.toJSON(src.left);\n            if (src.right) dest.right = self.toJSON(src.right);\n            return dest;\n        };\n        this.insert = function(point) {\n            function innerSearch(node, parent) {\n                if (node === null) return parent;\n                var dimension = dimensions[node.dimension];\n                if (point[dimension] < node.obj[dimension]) return innerSearch(node.left, node);\n                else return innerSearch(node.right, node);\n            }\n            var insertPosition = innerSearch(this.root, null), newNode, dimension;\n            if (insertPosition === null) {\n                this.root = new Node(point, 0, null);\n                return;\n            }\n            newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\n            dimension = dimensions[insertPosition.dimension];\n            if (point[dimension] < insertPosition.obj[dimension]) insertPosition.left = newNode;\n            else insertPosition.right = newNode;\n        };\n        this.remove = function(point) {\n            var node;\n            function nodeSearch(node) {\n                if (node === null) return null;\n                if (node.obj === point) return node;\n                var dimension = dimensions[node.dimension];\n                if (point[dimension] < node.obj[dimension]) return nodeSearch(node.left, node);\n                else return nodeSearch(node.right, node);\n            }\n            function removeNode(node) {\n                var nextNode, nextObj, pDimension;\n                function findMin(node, dim) {\n                    var dimension, own, left, right, min;\n                    if (node === null) return null;\n                    dimension = dimensions[dim];\n                    if (node.dimension === dim) {\n                        if (node.left !== null) return findMin(node.left, dim);\n                        return node;\n                    }\n                    own = node.obj[dimension];\n                    left = findMin(node.left, dim);\n                    right = findMin(node.right, dim);\n                    min = node;\n                    if (left !== null && left.obj[dimension] < own) min = left;\n                    if (right !== null && right.obj[dimension] < min.obj[dimension]) min = right;\n                    return min;\n                }\n                if (node.left === null && node.right === null) {\n                    if (node.parent === null) {\n                        self.root = null;\n                        return;\n                    }\n                    pDimension = dimensions[node.parent.dimension];\n                    if (node.obj[pDimension] < node.parent.obj[pDimension]) node.parent.left = null;\n                    else node.parent.right = null;\n                    return;\n                }\n                // If the right subtree is not empty, swap with the minimum element on the\n                // node's dimension. If it is empty, we swap the left and right subtrees and\n                // do the same.\n                if (node.right !== null) {\n                    nextNode = findMin(node.right, node.dimension);\n                    nextObj = nextNode.obj;\n                    removeNode(nextNode);\n                    node.obj = nextObj;\n                } else {\n                    nextNode = findMin(node.left, node.dimension);\n                    nextObj = nextNode.obj;\n                    removeNode(nextNode);\n                    node.right = node.left;\n                    node.left = null;\n                    node.obj = nextObj;\n                }\n            }\n            node = nodeSearch(self.root);\n            if (node === null) return;\n            removeNode(node);\n        };\n        this.nearest = function(point, maxNodes, maxDistance) {\n            var i, result, bestNodes;\n            bestNodes = new BinaryHeap(function(e) {\n                return -e[1];\n            });\n            function nearestSearch(node) {\n                var bestChild, dimension = dimensions[node.dimension], ownDistance = metric(point, node.obj), linearPoint = {}, linearDistance, otherChild, i;\n                function saveNode(node, distance) {\n                    bestNodes.push([\n                        node,\n                        distance\n                    ]);\n                    if (bestNodes.size() > maxNodes) bestNodes.pop();\n                }\n                for(i = 0; i < dimensions.length; i += 1)if (i === node.dimension) linearPoint[dimensions[i]] = point[dimensions[i]];\n                else linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n                linearDistance = metric(linearPoint, node.obj);\n                if (node.right === null && node.left === null) {\n                    if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) saveNode(node, ownDistance);\n                    return;\n                }\n                if (node.right === null) bestChild = node.left;\n                else if (node.left === null) bestChild = node.right;\n                else if (point[dimension] < node.obj[dimension]) bestChild = node.left;\n                else bestChild = node.right;\n                nearestSearch(bestChild);\n                if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) saveNode(node, ownDistance);\n                if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\n                    if (bestChild === node.left) otherChild = node.right;\n                    else otherChild = node.left;\n                    if (otherChild !== null) nearestSearch(otherChild);\n                }\n            }\n            if (maxDistance) for(i = 0; i < maxNodes; i += 1)bestNodes.push([\n                null,\n                maxDistance\n            ]);\n            if (self.root) nearestSearch(self.root);\n            result = [];\n            for(i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1)if (bestNodes.content[i][0]) result.push([\n                bestNodes.content[i][0].obj,\n                bestNodes.content[i][1]\n            ]);\n            return result;\n        };\n        this.balanceFactor = function() {\n            function height(node) {\n                if (node === null) return 0;\n                return Math.max(height(node.left), height(node.right)) + 1;\n            }\n            function count(node) {\n                if (node === null) return 0;\n                return count(node.left) + count(node.right) + 1;\n            }\n            return height(self.root) / (Math.log(count(self.root)) / Math.log(2));\n        };\n    }\n    // Binary heap implementation from:\n    // http://eloquentjavascript.net/appendix2.html\n    function BinaryHeap(scoreFunction) {\n        this.content = [];\n        this.scoreFunction = scoreFunction;\n    }\n    BinaryHeap.prototype = {\n        push: function(element) {\n            // Add the new element to the end of the array.\n            this.content.push(element);\n            // Allow it to bubble up.\n            this.bubbleUp(this.content.length - 1);\n        },\n        pop: function() {\n            // Store the first element so we can return it later.\n            var result = this.content[0];\n            // Get the element at the end of the array.\n            var end = this.content.pop();\n            // If there are any elements left, put the end element at the\n            // start, and let it sink down.\n            if (this.content.length > 0) {\n                this.content[0] = end;\n                this.sinkDown(0);\n            }\n            return result;\n        },\n        peek: function() {\n            return this.content[0];\n        },\n        remove: function(node) {\n            var len = this.content.length;\n            // To remove a value, we must search through the array to find\n            // it.\n            for(var i = 0; i < len; i++)if (this.content[i] == node) {\n                // When it is found, the process seen in 'pop' is repeated\n                // to fill up the hole.\n                var end = this.content.pop();\n                if (i != len - 1) {\n                    this.content[i] = end;\n                    if (this.scoreFunction(end) < this.scoreFunction(node)) this.bubbleUp(i);\n                    else this.sinkDown(i);\n                }\n                return;\n            }\n            throw new Error(\"Node not found.\");\n        },\n        size: function() {\n            return this.content.length;\n        },\n        bubbleUp: function(n) {\n            // Fetch the element that has to be moved.\n            var element = this.content[n];\n            // When at 0, an element can not go up any further.\n            while(n > 0){\n                // Compute the parent element's index, and fetch it.\n                var parentN = Math.floor((n + 1) / 2) - 1, parent = this.content[parentN];\n                // Swap the elements if the parent is greater.\n                if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n                    this.content[parentN] = element;\n                    this.content[n] = parent;\n                    // Update 'n' to continue at the new position.\n                    n = parentN;\n                } else break;\n            }\n        },\n        sinkDown: function(n) {\n            // Look up the target element and its score.\n            var length = this.content.length, element = this.content[n], elemScore = this.scoreFunction(element);\n            while(true){\n                // Compute the indices of the child elements.\n                var child2N = (n + 1) * 2, child1N = child2N - 1;\n                // This is used to store the new position of the element,\n                // if any.\n                var swap = null;\n                // If the first child exists (is inside the array)...\n                if (child1N < length) {\n                    // Look it up and compute its score.\n                    var child1 = this.content[child1N], child1Score = this.scoreFunction(child1);\n                    // If the score is less than our element's, we need to swap.\n                    if (child1Score < elemScore) swap = child1N;\n                }\n                // Do the same checks for the other child.\n                if (child2N < length) {\n                    var child2 = this.content[child2N], child2Score = this.scoreFunction(child2);\n                    if (child2Score < (swap == null ? elemScore : child1Score)) swap = child2N;\n                }\n                // If the element needs to be moved, swap it, and continue.\n                if (swap != null) {\n                    this.content[n] = this.content[swap];\n                    this.content[swap] = element;\n                    n = swap;\n                } else break;\n            }\n        }\n    };\n    exports1.kdTree = kdTree;\n    exports1.BinaryHeap = BinaryHeap;\n});\n\n\n// --- Cached elements and converter ---\nlet $4635365ae85fe8c7$var$cachedSvgElement = null;\nlet $4635365ae85fe8c7$var$cachedScaleBarElement = null;\nlet $4635365ae85fe8c7$var$cachedScaleTextElement = null;\nlet $4635365ae85fe8c7$var$cachedConverter = null;\nlet $4635365ae85fe8c7$var$cachedMapWidth = 0;\nlet $4635365ae85fe8c7$var$cachedMapHeight = 0;\nconst $4635365ae85fe8c7$var$EARTH_RADIUS_METERS = 6371000; // Define constant\nfunction $4635365ae85fe8c7$export$58834c9ab2105e58(width, height) {\n    // Only create a new projection if dimensions changed\n    if ($4635365ae85fe8c7$var$cachedConverter && $4635365ae85fe8c7$var$cachedMapWidth === width && $4635365ae85fe8c7$var$cachedMapHeight === height) return $4635365ae85fe8c7$var$cachedConverter;\n    console.log(`Creating new projection for ${width}x${height}`); // Log when it happens\n    const projection = d3.geoMercator()// const projection = d3.geoRobinson()\n    .scale(width / (2 * Math.PI)).translate([\n        width / 2,\n        height / 2\n    ]);\n    const converter = {\n        pixelToGeo: function(x, y) {\n            const [longitude, latitude] = projection.invert([\n                x,\n                y\n            ]);\n            return {\n                latitude: latitude,\n                longitude: longitude\n            };\n        },\n        geoToPixel: function(latitude, longitude) {\n            const [x, y] = projection([\n                longitude,\n                latitude\n            ]);\n            return {\n                x: x,\n                y: y\n            };\n        }\n    };\n    // Cache the new converter and dimensions\n    $4635365ae85fe8c7$var$cachedConverter = converter;\n    $4635365ae85fe8c7$var$cachedMapWidth = width;\n    $4635365ae85fe8c7$var$cachedMapHeight = height;\n    return converter;\n}\n/**\r\n * Calculates the real-world distance represented by a horizontal line\r\n * of a given pixel length at a specific Y-coordinate on the projected map.\r\n *\r\n * @param {number} barPixelLength - The desired visual length of the scale bar in pixels.\r\n * @param {number} scaleBarY - The vertical pixel coordinate for the center of the scale bar.\r\n * @param {number} mapWidth - The current width of the map container in pixels.\r\n * @param {number} mapHeight - The current height of the map container in pixels.\r\n * @param {object} converter - The coordinate converter object from createCoordinateConverter.\r\n * @returns {number} The calculated real-world distance in meters.\r\n */ function $4635365ae85fe8c7$var$calculateRealDistanceForPixelLength(barPixelLength, scaleBarY, mapWidth, mapHeight, converter) {\n    // Define the start and end X pixel coordinates for the bar, centered horizontally\n    const startX = mapWidth / 2 - barPixelLength / 2;\n    const endX = mapWidth / 2 + barPixelLength / 2;\n    // Convert these screen pixel points back to geographical coordinates\n    const geoStart = converter.pixelToGeo(startX, scaleBarY);\n    const geoEnd = converter.pixelToGeo(endX, scaleBarY);\n    // Ensure the conversion was successful (points might be off the globe)\n    if (!geoStart || !geoEnd || isNaN(geoStart.latitude) || isNaN(geoEnd.latitude)) {\n        console.warn(\"Scale bar position is off the projected map.\");\n        // Fallback or return 0\n        return 0;\n    }\n    // Calculate the great-circle distance between these two geographical points using d3\n    // d3.geoDistance returns radians; multiply by Earth radius in meters\n    const geoDistanceRadians = d3.geoDistance([\n        geoStart.longitude,\n        geoStart.latitude\n    ], [\n        geoEnd.longitude,\n        geoEnd.latitude\n    ]);\n    const realDistanceMeters = geoDistanceRadians * $4635365ae85fe8c7$var$EARTH_RADIUS_METERS;\n    return realDistanceMeters;\n}\nfunction $4635365ae85fe8c7$export$ce4840fad26380af() {\n    // --- Use cached elements ---\n    if (!$4635365ae85fe8c7$var$cachedSvgElement) $4635365ae85fe8c7$var$cachedSvgElement = document.querySelector('#world-map');\n    if (!$4635365ae85fe8c7$var$cachedScaleBarElement) $4635365ae85fe8c7$var$cachedScaleBarElement = document.querySelector('.scale-bar');\n    if (!$4635365ae85fe8c7$var$cachedScaleTextElement) $4635365ae85fe8c7$var$cachedScaleTextElement = document.querySelector('.scale-text');\n    const svg = $4635365ae85fe8c7$var$cachedSvgElement;\n    const scaleBar = $4635365ae85fe8c7$var$cachedScaleBarElement;\n    const scaleText = $4635365ae85fe8c7$var$cachedScaleTextElement;\n    // --- End Use cached elements ---\n    if (!svg || !scaleBar || !scaleText) // If elements still not found after first attempt, maybe log warning or exit\n    // console.warn(\"Scale bar elements not found.\"); \n    return;\n    const svgRect = svg.getBoundingClientRect();\n    const mapWidth = svgRect.width;\n    const mapHeight = svgRect.height;\n    // --- Use cached converter if dimensions match ---\n    const converter = $4635365ae85fe8c7$export$58834c9ab2105e58(mapWidth, mapHeight);\n    // --- End Use cached converter ---\n    // --- Define the scale bar properties ---\n    const desiredBarPixelLength = 100; // Let the visual bar be 100 pixels wide\n    // Position the scale bar vertically (e.g., 95% down the map)\n    const scaleBarYPosition = mapHeight * 0.95;\n    // Calculate the real-world distance this 100px bar represents at this Y position\n    const realDistanceMeters = $4635365ae85fe8c7$var$calculateRealDistanceForPixelLength(desiredBarPixelLength, scaleBarYPosition, mapWidth, mapHeight, converter);\n    if (realDistanceMeters === 0) {\n        // Handle cases where calculation failed (e.g., off-map)\n        scaleText.textContent = \"\";\n        scaleBar.style.width = `0px`;\n        return;\n    }\n    // --- Update visual elements ---\n    // Set the visual bar width\n    scaleBar.style.width = `${desiredBarPixelLength}px`;\n    // Position the bar (assuming CSS handles centering or absolute positioning)\n    // Example CSS-based centering is often cleaner:\n    // scaleBar.style.position = 'absolute';\n    // scaleBar.style.left = '50%';\n    // scaleBar.style.transform = 'translateX(-50%)'; // Center horizontally\n    // scaleBar.style.bottom = `${mapHeight * 0.05}px`; // e.g., 5% from bottom\n    // Format the text label to be user-friendly\n    let displayValue;\n    let displayUnit;\n    if (realDistanceMeters >= 1000) {\n        // Convert to kilometers and round appropriately\n        const kilometers = realDistanceMeters / 1000;\n        // Simple rounding for now, could be more sophisticated\n        displayValue = Math.round(kilometers);\n        displayUnit = \"km\";\n    } else {\n        // Keep in meters, perhaps round to nearest 10 or 50\n        displayValue = Math.round(realDistanceMeters / 10) * 10; // Round to nearest 10m\n        displayUnit = \"m\";\n    }\n    scaleText.textContent = `${displayValue} ${displayUnit}`;\n// Position the text (again, CSS is often preferred)\n// scaleText.style.position = 'absolute'; \n// scaleText.style.left = scaleBar.style.left; \n// scaleText.style.transform = scaleBar.style.transform; // Match bar centering\n// scaleText.style.bottom = `${parseFloat(scaleBar.style.bottom) + 15}px`; // Position above bar\n}\n// Add resize listener - consider debouncing/throttling if resize events fire rapidly\nlet $4635365ae85fe8c7$var$resizeTimeout;\nwindow.addEventListener('resize', ()=>{\n    clearTimeout($4635365ae85fe8c7$var$resizeTimeout);\n    $4635365ae85fe8c7$var$resizeTimeout = setTimeout($4635365ae85fe8c7$export$ce4840fad26380af, 100); // Debounce resize handler\n});\n// Initial update\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    // Ensure elements are cached on load\n    $4635365ae85fe8c7$var$cachedSvgElement = document.querySelector('#world-map');\n    $4635365ae85fe8c7$var$cachedScaleBarElement = document.querySelector('.scale-bar');\n    $4635365ae85fe8c7$var$cachedScaleTextElement = document.querySelector('.scale-text');\n    $4635365ae85fe8c7$export$ce4840fad26380af(); // Run initial update\n});\ndocument.addEventListener('click', (event)=>{\n    // --- Use cached SVG element ---\n    const svg = $4635365ae85fe8c7$var$cachedSvgElement || document.querySelector('#world-map');\n    if (!svg) return;\n    const svgRect = svg.getBoundingClientRect();\n    // Get click position relative to the map container\n    const svgX = event.clientX - svgRect.left;\n    const svgY = event.clientY - svgRect.top;\n    // --- Reuse or create converter for current dimensions ---\n    const converter = $4635365ae85fe8c7$export$58834c9ab2105e58(svgRect.width, svgRect.height);\n    // --- End Reuse or create converter ---\n    const geoCoords = converter.pixelToGeo(svgX, svgY);\n    if (geoCoords && !isNaN(geoCoords.latitude)) console.log(`click -> (${geoCoords.latitude.toFixed(3)}, ${geoCoords.longitude.toFixed(3)})`);\n    else console.log(\"Clicked outside projected area.\");\n});\n\n\n\n\nlet $25fa000d8b286cb3$var$windParticles = [];\nlet $25fa000d8b286cb3$var$windCanvas = null;\nlet $25fa000d8b286cb3$var$windCtx = null;\nconst $25fa000d8b286cb3$var$DEG_TO_RAD = Math.PI / 180;\nconst $25fa000d8b286cb3$var$PARTICLE_RESPAWN_FRACTION = 0.02;\nconst $25fa000d8b286cb3$var$MAX_TAIL_LENGTH = 10;\nfunction $25fa000d8b286cb3$export$720755392c964ba5() {\n    $25fa000d8b286cb3$var$windCanvas = document.getElementById('wind-canvas');\n    if (!$25fa000d8b286cb3$var$windCanvas) {\n        console.error(\"Wind canvas element not found!\");\n        return;\n    }\n    $25fa000d8b286cb3$var$windCtx = $25fa000d8b286cb3$var$windCanvas.getContext('2d');\n    if (!$25fa000d8b286cb3$var$windCtx) {\n        console.error(\"Could not get 2D context from wind canvas!\");\n        return;\n    }\n    $25fa000d8b286cb3$var$createWindParticles(10000, $25fa000d8b286cb3$var$windParticles);\n    console.log(\"Wind layer initialized with\", $25fa000d8b286cb3$var$windParticles.length, \"particles\");\n}\nfunction $25fa000d8b286cb3$var$createWindParticles(count, windParticles) {\n    for(let i = 0; i < count; i++)windParticles.push({\n        location: {\n            // Global bounds: latitude -90 to 90, longitude -180 to 180\n            latitude: Math.random() * 180 - 90,\n            longitude: Math.random() * 360 - 180\n        },\n        current: {\n            temperature2m: 0,\n            windSpeed10m: 0,\n            windDirection10m: 0\n        },\n        computed: {\n            opacity: 0.5,\n            color: 'rgba(255, 255, 255, 0.5)',\n            tail: []\n        }\n    });\n}\nfunction $25fa000d8b286cb3$export$8c8495f743cb3cff(elapsed) {\n    if (!$25fa000d8b286cb3$var$windCanvas || !$25fa000d8b286cb3$var$windCtx) {\n        console.warn(\"Wind canvas or context not initialized, skipping redraw.\");\n        return;\n    }\n    if (!(0, $9791a722e428427e$export$722377996733fc7a)) {\n        if (!window.hasLoggedMissingTree) {\n            console.warn(\"Weather data tree not available, skipping wind particle redraw.\");\n            window.hasLoggedMissingTree = true;\n        }\n        $25fa000d8b286cb3$var$windCtx.clearRect(0, 0, $25fa000d8b286cb3$var$windCanvas.width, $25fa000d8b286cb3$var$windCanvas.height);\n        return;\n    }\n    const worldMap = document.querySelector('#world-map');\n    if (!worldMap) return;\n    const mapRect = worldMap.getBoundingClientRect();\n    // Check if dimensions changed before resizing and clearing - might save some work\n    if ($25fa000d8b286cb3$var$windCanvas.width !== mapRect.width || $25fa000d8b286cb3$var$windCanvas.height !== mapRect.height) {\n        $25fa000d8b286cb3$var$windCanvas.width = mapRect.width;\n        $25fa000d8b286cb3$var$windCanvas.height = mapRect.height;\n    }\n    $25fa000d8b286cb3$var$windCtx.clearRect(0, 0, $25fa000d8b286cb3$var$windCanvas.width, $25fa000d8b286cb3$var$windCanvas.height);\n    const converter = $4635365ae85fe8c7$export$58834c9ab2105e58($25fa000d8b286cb3$var$windCanvas.width, $25fa000d8b286cb3$var$windCanvas.height);\n    const scaledElapsed = elapsed * 15; // Scale time factor once\n    // --- Particle Respawning (outside the loop) ---\n    const numToRespaw = Math.floor($25fa000d8b286cb3$var$windParticles.length * $25fa000d8b286cb3$var$PARTICLE_RESPAWN_FRACTION);\n    if (numToRespaw > 0) {\n        $25fa000d8b286cb3$var$windParticles.splice(0, numToRespaw); // Remove oldest particles\n        $25fa000d8b286cb3$var$createWindParticles(numToRespaw, $25fa000d8b286cb3$var$windParticles); // Add new ones\n    }\n    // --- End Particle Respawning ---\n    $25fa000d8b286cb3$var$windParticles.forEach((particle)=>{\n        // Calculate particle's current 3D position for KDTree search\n        const currentLatRad = particle.location.latitude * $25fa000d8b286cb3$var$DEG_TO_RAD; // Use constant\n        const currentLonRad = particle.location.longitude * $25fa000d8b286cb3$var$DEG_TO_RAD; // Use constant\n        const R = 1; // Unit sphere\n        particle.x = R * Math.cos(currentLatRad) * Math.cos(currentLonRad);\n        particle.y = R * Math.cos(currentLatRad) * Math.sin(currentLonRad);\n        particle.z = R * Math.sin(currentLatRad);\n        // Find nearest weather data point using the X,Y,Z based tree\n        let nearest = (0, $9791a722e428427e$export$722377996733fc7a).nearest(particle, 1);\n        if (!nearest || nearest.length === 0) return; // Skip if no data found\n        let [point, distance] = nearest[0]; // point is a WeatherData object\n        // --- Update particle properties based on the nearest point ---\n        const blendFactor = 0.05; // Adjust for faster/slower adaptation\n        particle.current.windSpeed10m += (point.current.windSpeed10m - particle.current.windSpeed10m) * blendFactor;\n        // Smoother angle interpolation (handle wrap-around)\n        let angleDiff = point.current.windDirection10m - particle.current.windDirection10m;\n        while(angleDiff <= -180)angleDiff += 360;\n        while(angleDiff > 180)angleDiff -= 360;\n        particle.current.windDirection10m += angleDiff * blendFactor;\n        particle.current.windDirection10m = (particle.current.windDirection10m + 360) % 360;\n        particle.computed.color = point.computed.color;\n        particle.computed.opacity = parseFloat(point.computed.opacity); // Ensure opacity is a number\n        // Convert wind speed (m/s) to approximate degrees latitude per ms\n        // Scaled elapsed time is used here\n        const speedDegPerMs = particle.current.windSpeed10m / 111000 * scaledElapsed;\n        // Convert meteorological wind direction to radians\n        const meteoDirectionRad = particle.current.windDirection10m * $25fa000d8b286cb3$var$DEG_TO_RAD; // Use constant\n        // Calculate V (Northward) and U (Eastward) components in degrees/ms\n        const vComponentDeg = speedDegPerMs * -Math.cos(meteoDirectionRad);\n        const uComponentDeg = speedDegPerMs * Math.sin(meteoDirectionRad);\n        // Calculate displacement in degrees\n        const deltaLat = vComponentDeg;\n        const lonScale = Math.cos(currentLatRad);\n        const deltaLon = lonScale > 0.01 ? uComponentDeg / lonScale : 0;\n        // --- Store previous pixel location for tail ---\n        const prevPixelX = particle.computed.pixelX;\n        const prevPixelY = particle.computed.pixelY;\n        // Update particle location\n        particle.location.latitude += deltaLat;\n        particle.location.longitude += deltaLon;\n        // Wrap around the planet\n        let wrapped = false;\n        if (particle.location.latitude > 90) {\n            particle.location.latitude = 180 - particle.location.latitude;\n            particle.location.longitude += 180;\n            wrapped = true;\n        } else if (particle.location.latitude < -90) {\n            particle.location.latitude = -180 - particle.location.latitude;\n            particle.location.longitude += 180;\n            wrapped = true;\n        }\n        if (particle.location.longitude > 180) {\n            particle.location.longitude -= 360;\n            wrapped = true;\n        } else if (particle.location.longitude < -180) {\n            particle.location.longitude += 360;\n            wrapped = true;\n        }\n        // --- Calculate new pixel position ONCE ---\n        const newPixelLocation = converter.geoToPixel(particle.location.latitude, particle.location.longitude);\n        particle.computed.pixelX = newPixelLocation.x;\n        particle.computed.pixelY = newPixelLocation.y;\n        // --- Tail Management ---\n        if (wrapped) particle.computed.tail = []; // Reset tail on wrap\n        else {\n            // Add previous *geo* coords to tail - needed if map resizes\n            particle.computed.tail.push({\n                latitude: particle.location.latitude - deltaLat,\n                longitude: particle.location.longitude - deltaLon // Approx previous geo\n            });\n            if (particle.computed.tail.length > $25fa000d8b286cb3$var$MAX_TAIL_LENGTH) particle.computed.tail.shift(); // Still using shift for now\n        }\n        // --- Draw Tail ---\n        if (particle.computed.tail.length > 1 && !wrapped && prevPixelX !== undefined && prevPixelY !== undefined) {\n            $25fa000d8b286cb3$var$windCtx.beginPath();\n            $25fa000d8b286cb3$var$windCtx.moveTo(prevPixelX, prevPixelY);\n            $25fa000d8b286cb3$var$windCtx.lineTo(particle.computed.pixelX, particle.computed.pixelY);\n            for(let i = particle.computed.tail.length - 2; i >= 0; i--){\n                const tailPixel = converter.geoToPixel(particle.computed.tail[i].latitude, particle.computed.tail[i].longitude);\n                $25fa000d8b286cb3$var$windCtx.lineTo(tailPixel.x, tailPixel.y);\n            }\n            $25fa000d8b286cb3$var$windCtx.strokeStyle = particle.computed.color;\n            $25fa000d8b286cb3$var$windCtx.globalAlpha = 0.3; // Fainter tail\n            $25fa000d8b286cb3$var$windCtx.lineWidth = 1;\n            $25fa000d8b286cb3$var$windCtx.stroke();\n        }\n        // --- Draw Particle Head ---\n        $25fa000d8b286cb3$var$drawDotOnCanvas($25fa000d8b286cb3$var$windCtx, particle.computed.pixelX, particle.computed.pixelY, particle.computed.opacity, particle.computed.color);\n    });\n}\nfunction $25fa000d8b286cb3$var$drawDotOnCanvas(ctx, x, y, opacity, color) {\n    ctx.fillStyle = color;\n    ctx.globalAlpha = opacity;\n    const screenWidth = window.innerWidth;\n    const screenHeight = window.innerHeight;\n    const screenSize = Math.min(screenWidth, screenHeight);\n    let size = 1;\n    if (screenSize >= 768) size = 3;\n    else if (screenSize >= 480) size = 2;\n    const halfSize = size / 2;\n    ctx.fillRect(Math.floor(x - halfSize), Math.floor(y - halfSize), size, size);\n}\nfunction $25fa000d8b286cb3$export$320c74c19c537cc() {\n    if ($25fa000d8b286cb3$var$windCtx && $25fa000d8b286cb3$var$windCanvas) $25fa000d8b286cb3$var$windCtx.clearRect(0, 0, $25fa000d8b286cb3$var$windCanvas.width, $25fa000d8b286cb3$var$windCanvas.height);\n    $25fa000d8b286cb3$var$windParticles = [];\n    console.log(\"Wind layer cleared.\");\n}\n\n\n// Function to load weather data from a static JSON file\nasync function $9791a722e428427e$var$loadWeatherDataFromFile(filePath) {\n    try {\n        const response = await fetch(filePath);\n        if (!response.ok) {\n            console.error(`Error fetching weather data file ${filePath}: ${response.status} ${response.statusText}`);\n            return null;\n        }\n        // Assuming the file contains the structure { timestamp: number, data: WeatherData[] }\n        // similar to the old cache format.\n        const cachedObject = await response.json();\n        if (!cachedObject || !cachedObject.data) {\n            console.error(`Invalid data structure in ${filePath}. Expected { timestamp: number, data: WeatherData[] }`);\n            return null;\n        }\n        const data = cachedObject.data;\n        console.log(`Successfully loaded ${data.length} weather data points from ${filePath}.`);\n        return data;\n    } catch (error) {\n        console.error(`Error loading or parsing weather data file ${filePath}:`, error);\n        return null;\n    }\n}\nlet $9791a722e428427e$export$38885f836d62c34e = [];\nlet $9791a722e428427e$var$canvas = null;\nlet $9791a722e428427e$var$ctx = null;\nlet $9791a722e428427e$export$722377996733fc7a = null;\nlet $9791a722e428427e$var$coordinateConverter = null;\nwindow.addEventListener('resize', function() {\n    clearTimeout(window.resizeTimer);\n    window.resizeTimer = setTimeout(function() {\n        $9791a722e428427e$var$redrawAllArrows();\n        $9791a722e428427e$var$setupTooltip();\n    }, 200);\n});\ndocument.addEventListener('DOMContentLoaded', async function() {\n    $9791a722e428427e$var$canvas = document.getElementById('arrow-canvas');\n    if (!$9791a722e428427e$var$canvas) {\n        console.error(\"Canvas element not found!\");\n        return;\n    }\n    $9791a722e428427e$var$ctx = $9791a722e428427e$var$canvas.getContext('2d');\n    if (!$9791a722e428427e$var$ctx) {\n        console.error(\"Could not get 2D context from canvas!\");\n        return;\n    }\n    $25fa000d8b286cb3$export$720755392c964ba5();\n    const staticDataPath = '/map/assets/weather_data_cache.json';\n    const loadedData = await $9791a722e428427e$var$loadWeatherDataFromFile(staticDataPath);\n    if (loadedData) {\n        $9791a722e428427e$export$38885f836d62c34e = loadedData;\n        // Add computed 3D coordinates (x, y, z) required for KDTree\n        $9791a722e428427e$export$38885f836d62c34e.forEach((weatherData)=>{\n            if (!weatherData.location) {\n                console.warn(\"Skipping data point with missing location:\", weatherData);\n                return; // Skip this data point if location is missing\n            }\n            const latRad = weatherData.location.latitude * Math.PI / 180;\n            const lonRad = weatherData.location.longitude * Math.PI / 180;\n            const R = 1;\n            weatherData.x = R * Math.cos(latRad) * Math.cos(lonRad);\n            weatherData.y = R * Math.cos(latRad) * Math.sin(lonRad);\n            weatherData.z = R * Math.sin(latRad);\n        });\n        $9791a722e428427e$export$722377996733fc7a = $9791a722e428427e$var$buildWeatherDataTree();\n        if ($9791a722e428427e$export$722377996733fc7a) {\n            console.log(\"KDTree built successfully from static file.\");\n            $9791a722e428427e$var$redrawAllArrows();\n            $9791a722e428427e$var$startWindAnimation();\n        } else console.error(\"Failed to build KDTree from static file data.\");\n    } else {\n        // Handle failure to load static data\n        console.error(`Failed to load weather data from ${staticDataPath}. Cannot initialize map features.`);\n        // Optionally display a message to the user on the page\n        const mapElement = document.getElementById('world-map');\n        if (mapElement) mapElement.innerHTML = `<p style=\"color: red; text-align: center; margin-top: 50px;\">Error: Could not load essential weather data.</p>`;\n        return; // Stop execution if data loading failed\n    }\n    // Store the converter for use in event listeners\n    $9791a722e428427e$var$coordinateConverter = $4635365ae85fe8c7$export$58834c9ab2105e58($9791a722e428427e$var$canvas.width, $9791a722e428427e$var$canvas.height);\n    // Setup tooltip interaction\n    $9791a722e428427e$var$setupTooltip();\n});\nfunction $9791a722e428427e$var$drawArrowOnCanvas(ctx, x, y, rotationDegrees, opacity, color) {\n    const size = 4;\n    const angleRad = rotationDegrees * Math.PI / 180;\n    ctx.save();\n    ctx.translate(x, y);\n    ctx.rotate(angleRad);\n    ctx.globalAlpha = opacity;\n    ctx.strokeStyle = color;\n    ctx.lineWidth = 1;\n    ctx.beginPath();\n    ctx.moveTo(-size, -size);\n    ctx.lineTo(0, 0);\n    ctx.lineTo(-size, size);\n    ctx.stroke();\n    ctx.restore();\n}\nfunction $9791a722e428427e$var$buildWeatherDataTree() {\n    if ($9791a722e428427e$export$38885f836d62c34e.length === 0 || !$9791a722e428427e$export$38885f836d62c34e[0].hasOwnProperty('x')) {\n        console.log(\"Cannot build weather data tree: no data points available or missing x,y,z coords.\");\n        return null;\n    }\n    function distance(a, b) {\n        const lat1 = a?.location?.latitude;\n        const lon1 = a?.location?.longitude;\n        const lat2 = b?.location?.latitude;\n        const lon2 = b?.location?.longitude;\n        // Convert degrees to radians\n        const latRad1 = lat1 * Math.PI / 180;\n        const lonRad1 = lon1 * Math.PI / 180;\n        const latRad2 = lat2 * Math.PI / 180;\n        const lonRad2 = lon2 * Math.PI / 180;\n        // Convert to 3D Cartesian coordinates (unit sphere R=1)\n        const x1 = Math.cos(latRad1) * Math.cos(lonRad1);\n        const y1 = Math.cos(latRad1) * Math.sin(lonRad1);\n        const z1 = Math.sin(latRad1);\n        const x2 = Math.cos(latRad2) * Math.cos(lonRad2);\n        const y2 = Math.cos(latRad2) * Math.sin(lonRad2);\n        const z2 = Math.sin(latRad2);\n        // Calculate Euclidean distance (chord length) in 3D space\n        const dx = x1 - x2;\n        const dy = y1 - y2;\n        const dz = z1 - z2;\n        const chordDistance = Math.sqrt(dx * dx + dy * dy + dz * dz);\n        // Return the chord distance\n        return chordDistance;\n    }\n    console.log(\"Building KDTree with geographic distance metric and data:\", $9791a722e428427e$export$38885f836d62c34e);\n    $9791a722e428427e$export$722377996733fc7a = new (0, $2a714b91454b8405$exports.kdTree)($9791a722e428427e$export$38885f836d62c34e, distance, [\n        'x',\n        'y',\n        'z'\n    ]);\n    console.log(\"KDTree built with data:\", $9791a722e428427e$export$722377996733fc7a);\n    return $9791a722e428427e$export$722377996733fc7a;\n}\nfunction $9791a722e428427e$var$redrawAllArrows() {\n    if (!$9791a722e428427e$var$canvas || !$9791a722e428427e$var$ctx) return;\n    const worldMap = document.querySelector('#world-map');\n    if (!worldMap) return;\n    const mapRect = worldMap.getBoundingClientRect();\n    $9791a722e428427e$var$canvas.width = mapRect.width;\n    $9791a722e428427e$var$canvas.height = mapRect.height;\n    $9791a722e428427e$var$ctx.clearRect(0, 0, $9791a722e428427e$var$canvas.width, $9791a722e428427e$var$canvas.height);\n    const converter = $4635365ae85fe8c7$export$58834c9ab2105e58($9791a722e428427e$var$canvas.width, $9791a722e428427e$var$canvas.height);\n    $9791a722e428427e$export$38885f836d62c34e.forEach((weatherData)=>{\n        const { location: location, current: current, computed: computed } = weatherData;\n        const pixelPos = converter.geoToPixel(location.latitude, location.longitude);\n        $9791a722e428427e$var$drawArrowOnCanvas($9791a722e428427e$var$ctx, pixelPos.x, pixelPos.y, current.windDirection10m, parseFloat(computed.opacity), computed.color);\n    });\n    $4635365ae85fe8c7$export$ce4840fad26380af();\n}\nfunction $9791a722e428427e$var$computeBorderColor(temperature2m) {\n    let r, g, b;\n    const tempCapped = Math.max(-15, Math.min(30, temperature2m));\n    if (tempCapped >= 15) {\n        const tempScaler = (tempCapped - 15) / 15;\n        r = 255;\n        g = Math.round(255 * (1 - tempScaler));\n        b = Math.round(255 * (1 - tempScaler));\n    } else {\n        const tempScaler = (tempCapped + 15) / 30;\n        r = Math.round(255 * tempScaler);\n        g = Math.round(255 * tempScaler);\n        b = 255;\n    }\n    return `rgb(${r}, ${g}, ${b})`;\n}\nconst $9791a722e428427e$var$ticksPerSecond = 30;\nlet $9791a722e428427e$var$lastDataUpdateTime = 0;\nfunction $9791a722e428427e$var$animateWindParticles() {\n    const now = Date.now();\n    const elapsed = now - $9791a722e428427e$var$lastDataUpdateTime;\n    if (elapsed >= 1000 / $9791a722e428427e$var$ticksPerSecond) {\n        $25fa000d8b286cb3$export$8c8495f743cb3cff(elapsed);\n        $9791a722e428427e$var$lastDataUpdateTime = now;\n    }\n    requestAnimationFrame($9791a722e428427e$var$animateWindParticles);\n}\nfunction $9791a722e428427e$var$startWindAnimation() {\n    $9791a722e428427e$var$lastDataUpdateTime = Date.now();\n    $9791a722e428427e$var$animateWindParticles();\n}\n// --- Tooltip Logic ---\nfunction $9791a722e428427e$var$setupTooltip() {\n    const mapElement = document.getElementById('world-map');\n    const tooltipElement = document.getElementById('tooltip');\n    if (!mapElement || !tooltipElement || !$9791a722e428427e$var$coordinateConverter) {\n        console.error(\"Map, tooltip, or coordinate converter not available for tooltip setup.\");\n        return;\n    }\n    mapElement.addEventListener('mousemove', (event)=>{\n        if (!$9791a722e428427e$export$722377996733fc7a) return; // Don't do anything if tree isn't ready\n        const rect = event.target.getBoundingClientRect();\n        const mouseX = event.clientX - rect.left;\n        const mouseY = event.clientY - rect.top;\n        // Convert pixel to geo\n        const geoCoords = $9791a722e428427e$var$coordinateConverter.pixelToGeo(mouseX, mouseY);\n        if (!geoCoords) {\n            tooltipElement.style.display = 'none';\n            return;\n        }\n        const { latitude: latitude, longitude: longitude } = geoCoords;\n        // Convert geo to x, y, z for KDTree query\n        const latRad = latitude * Math.PI / 180;\n        const lonRad = longitude * Math.PI / 180;\n        const R = 1;\n        const queryPoint = {\n            x: R * Math.cos(latRad) * Math.cos(lonRad),\n            y: R * Math.cos(latRad) * Math.sin(lonRad),\n            z: R * Math.sin(latRad),\n            // Add dummy location/current if needed by distance function, \n            // though the KDTree uses x,y,z primarily\n            location: {\n                latitude: latitude,\n                longitude: longitude\n            },\n            current: {\n                temperature2m: 0,\n                windSpeed10m: 0,\n                windDirection10m: 0\n            },\n            computed: {\n                opacity: '0',\n                color: ''\n            } // Add dummy computed if necessary\n        };\n        // Find nearest weather data point using the KDTree\n        const nearestResult = $9791a722e428427e$export$722377996733fc7a.nearest(queryPoint, 1);\n        if (nearestResult && nearestResult.length > 0) {\n            const [nearestData, distance] = nearestResult[0]; // nearestData is WeatherData\n            // Format the data for the tooltip\n            const temp = nearestData.current.temperature2m.toFixed(1);\n            const wind = nearestData.current.windSpeed10m.toFixed(1);\n            tooltipElement.innerHTML = `Temp: ${temp}\\xb0C\nWind: ${wind} m/s`;\n            // Position tooltip near cursor\n            // Adjust offsetX/offsetY to prevent tooltip from covering the cursor\n            const offsetX = 15;\n            const offsetY = 10;\n            tooltipElement.style.left = `${event.pageX + offsetX}px`;\n            tooltipElement.style.top = `${event.pageY + offsetY}px`;\n            tooltipElement.style.display = 'block';\n        } else tooltipElement.style.display = 'none';\n    });\n    mapElement.addEventListener('mouseout', ()=>{\n        tooltipElement.style.display = 'none';\n    });\n    console.log(\"Tooltip interactions initialized.\");\n}\n\n\n//# sourceMappingURL=map.3c69c090.js.map\n","import { kdTree as KDTree } from 'kd-tree-javascript/kdTree.js';\r\nimport * as points from './points';\r\nimport * as projection from './projection';\r\nimport * as wind from './wind';\r\n\r\nexport interface WeatherData {\r\n    current: {\r\n        temperature2m: number;\r\n        windSpeed10m: number;\r\n        windDirection10m: number;\r\n    };\r\n    location: {\r\n        latitude: number;\r\n        longitude: number;\r\n        timezoneAbbreviation: string | null;\r\n    };\r\n    computed: {\r\n        opacity: string;\r\n        color: string;\r\n        pixelPos?: { x: number; y: number };\r\n    };\r\n    x?: number;\r\n    y?: number;\r\n    z?: number;\r\n}\r\n\r\n// Function to load weather data from a static JSON file\r\nasync function loadWeatherDataFromFile(filePath: string): Promise<WeatherData[] | null> {\r\n    try {\r\n        const response = await fetch(filePath);\r\n        if (!response.ok) {\r\n            console.error(`Error fetching weather data file ${filePath}: ${response.status} ${response.statusText}`);\r\n            return null;\r\n        }\r\n        // Assuming the file contains the structure { timestamp: number, data: WeatherData[] }\r\n        // similar to the old cache format.\r\n        const cachedObject = await response.json(); \r\n        if (!cachedObject || !cachedObject.data) {\r\n            console.error(`Invalid data structure in ${filePath}. Expected { timestamp: number, data: WeatherData[] }`);\r\n            return null;\r\n        }\r\n        const data: WeatherData[] = cachedObject.data;\r\n\r\n        console.log(`Successfully loaded ${data.length} weather data points from ${filePath}.`);\r\n        return data;\r\n    } catch (error) {\r\n        console.error(`Error loading or parsing weather data file ${filePath}:`, error);\r\n        return null;\r\n    }\r\n}\r\n\r\nexport let globalWeatherDataCollection: WeatherData[] = [];\r\nlet canvas: HTMLCanvasElement | null = null;\r\nlet ctx: CanvasRenderingContext2D | null = null;\r\nexport let weatherDataTree: KDTree | null = null;\r\nlet coordinateConverter: ReturnType<typeof projection.createCoordinateConverter> | null = null;\r\n\r\ndeclare global {\r\n    interface Window {\r\n        resizeTimer: ReturnType<typeof setTimeout>;\r\n    }\r\n}\r\n\r\nwindow.addEventListener('resize', function() {\r\n    clearTimeout(window.resizeTimer);\r\n    window.resizeTimer = setTimeout(function() {\r\n        redrawAllArrows();\r\n        setupTooltip();\r\n    }, 200);\r\n});\r\n\r\ndocument.addEventListener('DOMContentLoaded', async function() {\r\n    canvas = document.getElementById('arrow-canvas') as HTMLCanvasElement;\r\n    if (!canvas) {\r\n        console.error(\"Canvas element not found!\");\r\n        return;\r\n    }\r\n    ctx = canvas.getContext('2d');\r\n    if (!ctx) {\r\n        console.error(\"Could not get 2D context from canvas!\");\r\n        return;\r\n    }\r\n\r\n    wind.initializeWindLayer();\r\n\r\n    const staticDataPath = '/map/assets/weather_data_cache.json';\r\n    const loadedData = await loadWeatherDataFromFile(staticDataPath);\r\n\r\n    if (loadedData) {\r\n        globalWeatherDataCollection = loadedData;\r\n\r\n        // Add computed 3D coordinates (x, y, z) required for KDTree\r\n        globalWeatherDataCollection.forEach(weatherData => {\r\n            if (!weatherData.location) {\r\n                console.warn(\"Skipping data point with missing location:\", weatherData);\r\n                return; // Skip this data point if location is missing\r\n            }\r\n            const latRad = weatherData.location.latitude * Math.PI / 180;\r\n            const lonRad = weatherData.location.longitude * Math.PI / 180;\r\n            const R = 1;\r\n            weatherData.x = R * Math.cos(latRad) * Math.cos(lonRad);\r\n            weatherData.y = R * Math.cos(latRad) * Math.sin(lonRad);\r\n            weatherData.z = R * Math.sin(latRad);\r\n        });\r\n\r\n        weatherDataTree = buildWeatherDataTree();\r\n        if (weatherDataTree) {\r\n            console.log(\"KDTree built successfully from static file.\");\r\n            redrawAllArrows(); \r\n            startWindAnimation();\r\n        } else {\r\n            console.error(\"Failed to build KDTree from static file data.\");\r\n        }\r\n    } else {\r\n        // Handle failure to load static data\r\n        console.error(`Failed to load weather data from ${staticDataPath}. Cannot initialize map features.`);\r\n        // Optionally display a message to the user on the page\r\n        const mapElement = document.getElementById('world-map');\r\n        if (mapElement) {\r\n            mapElement.innerHTML = `<p style=\"color: red; text-align: center; margin-top: 50px;\">Error: Could not load essential weather data.</p>`;\r\n        }\r\n        return; // Stop execution if data loading failed\r\n    }\r\n\r\n    // Store the converter for use in event listeners\r\n    coordinateConverter = projection.createCoordinateConverter(canvas.width, canvas.height);\r\n\r\n    // Setup tooltip interaction\r\n    setupTooltip();\r\n});\r\n\r\nfunction drawArrowOnCanvas(\r\n    ctx: CanvasRenderingContext2D,\r\n    x: number,\r\n    y: number,\r\n    rotationDegrees: number,\r\n    opacity: number,\r\n    color: string\r\n) {\r\n    const size = 4;\r\n    const angleRad = rotationDegrees * Math.PI / 180;\r\n\r\n    ctx.save();\r\n    ctx.translate(x, y);\r\n    ctx.rotate(angleRad);\r\n    ctx.globalAlpha = opacity;\r\n    ctx.strokeStyle = color;\r\n    ctx.lineWidth = 1;\r\n\r\n    ctx.beginPath();\r\n    ctx.moveTo(-size, -size);\r\n    ctx.lineTo(0, 0);\r\n    ctx.lineTo(-size, size);\r\n    ctx.stroke();\r\n    ctx.restore();\r\n}\r\n\r\nfunction buildWeatherDataTree(): KDTree | null {\r\n    if (globalWeatherDataCollection.length === 0 || !globalWeatherDataCollection[0].hasOwnProperty('x')) {\r\n        console.log(\"Cannot build weather data tree: no data points available or missing x,y,z coords.\");\r\n        return null;\r\n    }\r\n\r\n    function distance(a: wind.WindParticle | WeatherData, b: WeatherData): number {\r\n        const lat1 = a?.location?.latitude;\r\n        const lon1 = a?.location?.longitude;\r\n        const lat2 = b?.location?.latitude;\r\n        const lon2 = b?.location?.longitude;\r\n\r\n        // Convert degrees to radians\r\n        const latRad1 = lat1 * Math.PI / 180;\r\n        const lonRad1 = lon1 * Math.PI / 180;\r\n        const latRad2 = lat2 * Math.PI / 180;\r\n        const lonRad2 = lon2 * Math.PI / 180;\r\n\r\n        // Convert to 3D Cartesian coordinates (unit sphere R=1)\r\n        const x1 = Math.cos(latRad1) * Math.cos(lonRad1);\r\n        const y1 = Math.cos(latRad1) * Math.sin(lonRad1);\r\n        const z1 = Math.sin(latRad1);\r\n\r\n        const x2 = Math.cos(latRad2) * Math.cos(lonRad2);\r\n        const y2 = Math.cos(latRad2) * Math.sin(lonRad2);\r\n        const z2 = Math.sin(latRad2);\r\n\r\n        // Calculate Euclidean distance (chord length) in 3D space\r\n        const dx = x1 - x2;\r\n        const dy = y1 - y2;\r\n        const dz = z1 - z2;\r\n        const chordDistance = Math.sqrt(dx*dx + dy*dy + dz*dz);\r\n\r\n        // Return the chord distance\r\n        return chordDistance;\r\n    }\r\n\r\n    console.log(\"Building KDTree with geographic distance metric and data:\", globalWeatherDataCollection);\r\n\r\n    weatherDataTree = new KDTree(\r\n        globalWeatherDataCollection,\r\n        distance,\r\n        ['x', 'y', 'z']\r\n    );\r\n\tconsole.log(\"KDTree built with data:\", weatherDataTree);\r\n\treturn weatherDataTree;\r\n}\r\n\r\nfunction redrawAllArrows() {\r\n    if (!canvas || !ctx) return;\r\n\r\n    const worldMap = document.querySelector('#world-map');\r\n    if (!worldMap) return;\r\n\r\n    const mapRect = worldMap.getBoundingClientRect();\r\n    canvas.width = mapRect.width;\r\n    canvas.height = mapRect.height;\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    const converter = projection.createCoordinateConverter(canvas.width, canvas.height);\r\n    globalWeatherDataCollection.forEach(weatherData => {\r\n        const { location, current, computed } = weatherData;\r\n        const pixelPos = converter.geoToPixel(location.latitude, location.longitude);\r\n        drawArrowOnCanvas(\r\n            ctx!,\r\n            pixelPos.x,\r\n            pixelPos.y,\r\n            current.windDirection10m,\r\n            parseFloat(computed.opacity),\r\n            computed.color\r\n        );\t\r\n    });\r\n    projection.updateScaleBar();\r\n}\r\n\r\nfunction computeBorderColor(temperature2m: number): string {\r\n    let r, g, b;\r\n    const tempCapped = Math.max(-15, Math.min(30, temperature2m));\r\n\r\n    if (tempCapped >= 15) {\r\n        const tempScaler = (tempCapped - 15) / 15;\r\n        r = 255;\r\n        g = Math.round(255 * (1 - tempScaler));\r\n        b = Math.round(255 * (1 - tempScaler));\r\n    } else {\r\n        const tempScaler = (tempCapped + 15) / 30;\r\n        r = Math.round(255 * tempScaler);\r\n        g = Math.round(255 * tempScaler);\r\n        b = 255;\r\n    }\r\n    return `rgb(${r}, ${g}, ${b})`;\r\n}\r\n\r\nconst ticksPerSecond = 30;\r\nlet lastDataUpdateTime = 0;\r\n\r\nfunction animateWindParticles() {\r\n    const now = Date.now();\r\n    const elapsed = now - lastDataUpdateTime;\r\n\r\n    if (elapsed >= 1000 / ticksPerSecond) {\r\n        wind.redrawWindParticles(elapsed);\r\n        lastDataUpdateTime = now;\r\n    }\r\n\r\n    requestAnimationFrame(animateWindParticles);\r\n}\r\n\r\nfunction startWindAnimation() {\r\n    lastDataUpdateTime = Date.now();\r\n    animateWindParticles();\r\n}\r\n\r\n// --- Tooltip Logic ---\r\n\r\nfunction setupTooltip() {\r\n    const mapElement = document.getElementById('world-map');\r\n    const tooltipElement = document.getElementById('tooltip');\r\n\r\n    if (!mapElement || !tooltipElement || !coordinateConverter) {\r\n        console.error(\"Map, tooltip, or coordinate converter not available for tooltip setup.\");\r\n        return;\r\n    }\r\n\r\n    mapElement.addEventListener('mousemove', (event) => {\r\n        if (!weatherDataTree) return; // Don't do anything if tree isn't ready\r\n\r\n        const rect = (event.target as Element).getBoundingClientRect();\r\n        const mouseX = event.clientX - rect.left;\r\n        const mouseY = event.clientY - rect.top;\r\n\r\n        // Convert pixel to geo\r\n        const geoCoords = coordinateConverter!.pixelToGeo(mouseX, mouseY);\r\n\r\n        if (!geoCoords) { // Mouse might be off the projected map\r\n            tooltipElement.style.display = 'none';\r\n            return;\r\n        }\r\n\r\n        const { latitude, longitude } = geoCoords;\r\n\r\n        // Convert geo to x, y, z for KDTree query\r\n        const latRad = latitude * Math.PI / 180;\r\n        const lonRad = longitude * Math.PI / 180;\r\n        const R = 1;\r\n        const queryPoint = {\r\n            x: R * Math.cos(latRad) * Math.cos(lonRad),\r\n            y: R * Math.cos(latRad) * Math.sin(lonRad),\r\n            z: R * Math.sin(latRad),\r\n            // Add dummy location/current if needed by distance function, \r\n            // though the KDTree uses x,y,z primarily\r\n            location: { latitude, longitude }, \r\n            current: { temperature2m: 0, windSpeed10m: 0, windDirection10m: 0 },\r\n            computed: { opacity: '0', color: ''} // Add dummy computed if necessary\r\n        };\r\n\r\n        // Find nearest weather data point using the KDTree\r\n        const nearestResult = weatherDataTree.nearest(queryPoint, 1);\r\n        if (nearestResult && nearestResult.length > 0) {\r\n            const [nearestData, distance] = nearestResult[0]; // nearestData is WeatherData\r\n            \r\n            // Format the data for the tooltip\r\n            const temp = nearestData.current.temperature2m.toFixed(1);\r\n            const wind = nearestData.current.windSpeed10m.toFixed(1);\r\n            tooltipElement.innerHTML = `Temp: ${temp}C\\nWind: ${wind} m/s`;\r\n\r\n            // Position tooltip near cursor\r\n            // Adjust offsetX/offsetY to prevent tooltip from covering the cursor\r\n            const offsetX = 15;\r\n            const offsetY = 10;\r\n            tooltipElement.style.left = `${event.pageX + offsetX}px`;\r\n            tooltipElement.style.top = `${event.pageY + offsetY}px`;\r\n            tooltipElement.style.display = 'block';\r\n        } else {\r\n            tooltipElement.style.display = 'none';\r\n        }\r\n    });\r\n\r\n    mapElement.addEventListener('mouseout', () => {\r\n        tooltipElement.style.display = 'none';\r\n    });\r\n\r\n    console.log(\"Tooltip interactions initialized.\");\r\n}","/**\n * k-d Tree JavaScript - V 1.01\n *\n * https://github.com/ubilabs/kd-tree-javascript\n *\n * @author Mircea Pricop <pricop@ubilabs.net>, 2012\n * @author Martin Kleppe <kleppe@ubilabs.net>, 2012\n * @author Ubilabs http://ubilabs.net, 2012\n * @license MIT License <http://www.opensource.org/licenses/mit-license.php>\n */\n\n (function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define(['exports'], factory);\n    } else if (typeof exports === 'object') {\n        factory(exports);\n    } else {\n        factory(root);\n    }\n}(this, function (exports) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n        median,\n        node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function (a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    // Reloads a serialied tree\n    function loadTree (data) {\n      // Just need to restore the `parent` parameter\n      self.root = data;\n\n      function restoreParent (root) {\n        if (root.left) {\n          root.left.parent = root;\n          restoreParent(root.left);\n        }\n\n        if (root.right) {\n          root.right.parent = root;\n          restoreParent(root.right);\n        }\n      }\n\n      restoreParent(self.root);\n    }\n\n    // If points is not an array, assume we're loading a pre-built tree\n    if (!Array.isArray(points)) loadTree(points, metric, dimensions);\n    else this.root = buildTree(points, 0, null);\n\n    // Convert to a JSON serializable structure; this just requires removing\n    // the `parent` property\n    this.toJSON = function (src) {\n      if (!src) src = this.root;\n      var dest = new Node(src.obj, src.dimension, null);\n      if (src.left) dest.left = self.toJSON(src.left);\n      if (src.right) dest.right = self.toJSON(src.right);\n      return dest;\n    };\n\n    this.insert = function (point) {\n      function innerSearch(node, parent) {\n\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n        newNode,\n        dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(point, (insertPosition.dimension + 1) % dimensions.length, insertPosition);\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.remove = function (point) {\n      var node;\n\n      function nodeSearch(node) {\n        if (node === null) {\n          return null;\n        }\n\n        if (node.obj === point) {\n          return node;\n        }\n\n        var dimension = dimensions[node.dimension];\n\n        if (point[dimension] < node.obj[dimension]) {\n          return nodeSearch(node.left, node);\n        } else {\n          return nodeSearch(node.right, node);\n        }\n      }\n\n      function removeNode(node) {\n        var nextNode,\n          nextObj,\n          pDimension;\n\n        function findMin(node, dim) {\n          var dimension,\n            own,\n            left,\n            right,\n            min;\n\n          if (node === null) {\n            return null;\n          }\n\n          dimension = dimensions[dim];\n\n          if (node.dimension === dim) {\n            if (node.left !== null) {\n              return findMin(node.left, dim);\n            }\n            return node;\n          }\n\n          own = node.obj[dimension];\n          left = findMin(node.left, dim);\n          right = findMin(node.right, dim);\n          min = node;\n\n          if (left !== null && left.obj[dimension] < own) {\n            min = left;\n          }\n          if (right !== null && right.obj[dimension] < min.obj[dimension]) {\n            min = right;\n          }\n          return min;\n        }\n\n        if (node.left === null && node.right === null) {\n          if (node.parent === null) {\n            self.root = null;\n            return;\n          }\n\n          pDimension = dimensions[node.parent.dimension];\n\n          if (node.obj[pDimension] < node.parent.obj[pDimension]) {\n            node.parent.left = null;\n          } else {\n            node.parent.right = null;\n          }\n          return;\n        }\n\n        // If the right subtree is not empty, swap with the minimum element on the\n        // node's dimension. If it is empty, we swap the left and right subtrees and\n        // do the same.\n        if (node.right !== null) {\n          nextNode = findMin(node.right, node.dimension);\n          nextObj = nextNode.obj;\n          removeNode(nextNode);\n          node.obj = nextObj;\n        } else {\n          nextNode = findMin(node.left, node.dimension);\n          nextObj = nextNode.obj;\n          removeNode(nextNode);\n          node.right = node.left;\n          node.left = null;\n          node.obj = nextObj;\n        }\n\n      }\n\n      node = nodeSearch(self.root);\n\n      if (node === null) { return; }\n\n      removeNode(node);\n    };\n\n    this.nearest = function (point, maxNodes, maxDistance) {\n      var i,\n        result,\n        bestNodes;\n\n      bestNodes = new BinaryHeap(\n        function (e) { return -e[1]; }\n      );\n\n      function nearestSearch(node) {\n        var bestChild,\n          dimension = dimensions[node.dimension],\n          ownDistance = metric(point, node.obj),\n          linearPoint = {},\n          linearDistance,\n          otherChild,\n          i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (bestNodes.size() < maxNodes || Math.abs(linearDistance) < bestNodes.peek()[1]) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if(self.root)\n        nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n\n    this.balanceFactor = function () {\n      function height(node) {\n        if (node === null) {\n          return 0;\n        }\n        return Math.max(height(node.left), height(node.right)) + 1;\n      }\n\n      function count(node) {\n        if (node === null) {\n          return 0;\n        }\n        return count(node.left) + count(node.right) + 1;\n      }\n\n      return height(self.root) / (Math.log(count(self.root)) / Math.log(2));\n    };\n  }\n\n  // Binary heap implementation from:\n  // http://eloquentjavascript.net/appendix2.html\n\n  function BinaryHeap(scoreFunction){\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    remove: function(node) {\n      var len = this.content.length;\n      // To remove a value, we must search through the array to find\n      // it.\n      for (var i = 0; i < len; i++) {\n        if (this.content[i] == node) {\n          // When it is found, the process seen in 'pop' is repeated\n          // to fill up the hole.\n          var end = this.content.pop();\n          if (i != len - 1) {\n            this.content[i] = end;\n            if (this.scoreFunction(end) < this.scoreFunction(node))\n              this.bubbleUp(i);\n            else\n              this.sinkDown(i);\n          }\n          return;\n        }\n      }\n      throw new Error(\"Node not found.\");\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n            parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n          element = this.content[n],\n          elemScore = this.scoreFunction(element);\n\n      while(true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2, child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n              child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore)\n            swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n              child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)){\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  exports.kdTree = kdTree;\n  exports.BinaryHeap = BinaryHeap;\n}));\n","// --- Cached elements and converter ---\r\nlet cachedSvgElement = null;\r\nlet cachedScaleBarElement = null;\r\nlet cachedScaleTextElement = null;\r\nlet cachedConverter = null;\r\nlet cachedMapWidth = 0;\r\nlet cachedMapHeight = 0;\r\nconst EARTH_RADIUS_METERS = 6371000; // Define constant\r\n\r\nfunction createCoordinateConverter(width, height) {\r\n    // Only create a new projection if dimensions changed\r\n    if (cachedConverter && cachedMapWidth === width && cachedMapHeight === height) {\r\n        return cachedConverter;\r\n    }\r\n\r\n    console.log(`Creating new projection for ${width}x${height}`); // Log when it happens\r\n    const projection = d3.geoMercator()\r\n    // const projection = d3.geoRobinson()\r\n        .scale(width / (2 * Math.PI))\r\n        .translate([width / 2, height / 2]);\r\n\r\n    const converter = {\r\n        pixelToGeo: function(x, y) {\r\n            const [longitude, latitude] = projection.invert([x, y]);\r\n            return { latitude, longitude };\r\n        },\r\n        geoToPixel: function(latitude, longitude) {\r\n            const [x, y] = projection([longitude, latitude]);\r\n            return { x, y };\r\n        }\r\n    };\r\n\r\n    // Cache the new converter and dimensions\r\n    cachedConverter = converter;\r\n    cachedMapWidth = width;\r\n    cachedMapHeight = height;\r\n    return converter;\r\n}\r\n\r\n/**\r\n * Calculates the real-world distance represented by a horizontal line\r\n * of a given pixel length at a specific Y-coordinate on the projected map.\r\n *\r\n * @param {number} barPixelLength - The desired visual length of the scale bar in pixels.\r\n * @param {number} scaleBarY - The vertical pixel coordinate for the center of the scale bar.\r\n * @param {number} mapWidth - The current width of the map container in pixels.\r\n * @param {number} mapHeight - The current height of the map container in pixels.\r\n * @param {object} converter - The coordinate converter object from createCoordinateConverter.\r\n * @returns {number} The calculated real-world distance in meters.\r\n */\r\nfunction calculateRealDistanceForPixelLength(barPixelLength, scaleBarY, mapWidth, mapHeight, converter) {\r\n    // Define the start and end X pixel coordinates for the bar, centered horizontally\r\n    const startX = (mapWidth / 2) - (barPixelLength / 2);\r\n    const endX = (mapWidth / 2) + (barPixelLength / 2);\r\n\r\n    // Convert these screen pixel points back to geographical coordinates\r\n    const geoStart = converter.pixelToGeo(startX, scaleBarY);\r\n    const geoEnd = converter.pixelToGeo(endX, scaleBarY);\r\n\r\n    // Ensure the conversion was successful (points might be off the globe)\r\n    if (!geoStart || !geoEnd || isNaN(geoStart.latitude) || isNaN(geoEnd.latitude)) {\r\n        console.warn(\"Scale bar position is off the projected map.\");\r\n        // Fallback or return 0\r\n        return 0;\r\n    }\r\n\r\n    // Calculate the great-circle distance between these two geographical points using d3\r\n    // d3.geoDistance returns radians; multiply by Earth radius in meters\r\n    const geoDistanceRadians = d3.geoDistance(\r\n        [geoStart.longitude, geoStart.latitude],\r\n        [geoEnd.longitude, geoEnd.latitude]\r\n    );\r\n\r\n    const realDistanceMeters = geoDistanceRadians * EARTH_RADIUS_METERS;\r\n\r\n    return realDistanceMeters;\r\n}\r\n\r\nfunction updateScaleBar() {\r\n    // --- Use cached elements ---\r\n    if (!cachedSvgElement) cachedSvgElement = document.querySelector('#world-map');\r\n    if (!cachedScaleBarElement) cachedScaleBarElement = document.querySelector('.scale-bar');\r\n    if (!cachedScaleTextElement) cachedScaleTextElement = document.querySelector('.scale-text');\r\n\r\n    const svg = cachedSvgElement;\r\n    const scaleBar = cachedScaleBarElement;\r\n    const scaleText = cachedScaleTextElement;\r\n    // --- End Use cached elements ---\r\n\r\n    if (!svg || !scaleBar || !scaleText) {\r\n        // If elements still not found after first attempt, maybe log warning or exit\r\n        // console.warn(\"Scale bar elements not found.\"); \r\n        return;\r\n    }\r\n\r\n    const svgRect = svg.getBoundingClientRect();\r\n    const mapWidth = svgRect.width;\r\n    const mapHeight = svgRect.height;\r\n\r\n    // --- Use cached converter if dimensions match ---\r\n    const converter = createCoordinateConverter(mapWidth, mapHeight);\r\n    // --- End Use cached converter ---\r\n\r\n    // --- Define the scale bar properties ---\r\n    const desiredBarPixelLength = 100; // Let the visual bar be 100 pixels wide\r\n    // Position the scale bar vertically (e.g., 95% down the map)\r\n    const scaleBarYPosition = mapHeight * 0.95;\r\n\r\n    // Calculate the real-world distance this 100px bar represents at this Y position\r\n    const realDistanceMeters = calculateRealDistanceForPixelLength(\r\n        desiredBarPixelLength,\r\n        scaleBarYPosition,\r\n        mapWidth,\r\n        mapHeight,\r\n        converter\r\n    );\r\n\r\n    if (realDistanceMeters === 0) {\r\n        // Handle cases where calculation failed (e.g., off-map)\r\n        scaleText.textContent = \"\";\r\n        scaleBar.style.width = `0px`;\r\n        return;\r\n    }\r\n\r\n    // --- Update visual elements ---\r\n    // Set the visual bar width\r\n    scaleBar.style.width = `${desiredBarPixelLength}px`;\r\n    // Position the bar (assuming CSS handles centering or absolute positioning)\r\n    // Example CSS-based centering is often cleaner:\r\n    // scaleBar.style.position = 'absolute';\r\n    // scaleBar.style.left = '50%';\r\n    // scaleBar.style.transform = 'translateX(-50%)'; // Center horizontally\r\n    // scaleBar.style.bottom = `${mapHeight * 0.05}px`; // e.g., 5% from bottom\r\n\r\n\r\n    // Format the text label to be user-friendly\r\n    let displayValue;\r\n    let displayUnit;\r\n\r\n    if (realDistanceMeters >= 1000) {\r\n        // Convert to kilometers and round appropriately\r\n        const kilometers = realDistanceMeters / 1000;\r\n        // Simple rounding for now, could be more sophisticated\r\n        displayValue = Math.round(kilometers);\r\n        displayUnit = \"km\";\r\n    } else {\r\n        // Keep in meters, perhaps round to nearest 10 or 50\r\n        displayValue = Math.round(realDistanceMeters / 10) * 10; // Round to nearest 10m\r\n        displayUnit = \"m\";\r\n    }\r\n\r\n    scaleText.textContent = `${displayValue} ${displayUnit}`;\r\n    // Position the text (again, CSS is often preferred)\r\n    // scaleText.style.position = 'absolute'; \r\n    // scaleText.style.left = scaleBar.style.left; \r\n    // scaleText.style.transform = scaleBar.style.transform; // Match bar centering\r\n    // scaleText.style.bottom = `${parseFloat(scaleBar.style.bottom) + 15}px`; // Position above bar\r\n}\r\n\r\n// Add resize listener - consider debouncing/throttling if resize events fire rapidly\r\nlet resizeTimeout;\r\nwindow.addEventListener('resize', () => {\r\n    clearTimeout(resizeTimeout);\r\n    resizeTimeout = setTimeout(updateScaleBar, 100); // Debounce resize handler\r\n});\r\n\r\n// Initial update\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    // Ensure elements are cached on load\r\n    cachedSvgElement = document.querySelector('#world-map');\r\n    cachedScaleBarElement = document.querySelector('.scale-bar');\r\n    cachedScaleTextElement = document.querySelector('.scale-text');\r\n    updateScaleBar(); // Run initial update\r\n});\r\n\r\ndocument.addEventListener('click', (event) => {\r\n    // --- Use cached SVG element ---\r\n    const svg = cachedSvgElement || document.querySelector('#world-map'); \r\n    if (!svg) return;\r\n\r\n    const svgRect = svg.getBoundingClientRect();\r\n\r\n    // Get click position relative to the map container\r\n    const svgX = event.clientX - svgRect.left;\r\n    const svgY = event.clientY - svgRect.top;\r\n\r\n    // --- Reuse or create converter for current dimensions ---\r\n    const converter = createCoordinateConverter(svgRect.width, svgRect.height);\r\n    // --- End Reuse or create converter ---\r\n\r\n    const geoCoords = converter.pixelToGeo(svgX, svgY);\r\n\r\n    if (geoCoords && !isNaN(geoCoords.latitude)) {\r\n     console.log(`click -> (${geoCoords.latitude.toFixed(3)}, ${geoCoords.longitude.toFixed(3)})`);\r\n    } else {\r\n     console.log(\"Clicked outside projected area.\");\r\n    }\r\n});\r\n\r\nexport { createCoordinateConverter, updateScaleBar }; ","import * as projection from './projection';\r\nimport { weatherDataTree } from './data';\r\n\r\nexport interface WindParticle {\r\n\tcurrent: {\r\n\t\ttemperature2m: number;\r\n\t\twindSpeed10m: number;\r\n\t\twindDirection10m: number;\r\n\t};\r\n\r\n\tlocation: {\r\n\t\tlatitude: number;\r\n\t\tlongitude: number;\r\n\t};\r\n\r\n\tcomputed: {\r\n\t\topacity: number;\r\n\t\tcolor: string;\r\n\t\ttail: {latitude: number, longitude: number}[];\r\n\t\tpixelX?: number; \r\n        pixelY?: number; \r\n\t};\r\n\r\n    x?: number;\r\n    y?: number;\r\n    z?: number;\r\n}\r\n\r\ndeclare global {\r\n    interface Window {\r\n        hasLoggedMissingTree?: boolean;\r\n    }\r\n}\r\n\r\nlet windParticles: WindParticle[] = [];\r\nlet windCanvas: HTMLCanvasElement | null = null;\r\nlet windCtx: CanvasRenderingContext2D | null = null;\r\nconst DEG_TO_RAD = Math.PI / 180;\r\nconst PARTICLE_RESPAWN_FRACTION = 0.02;\r\nconst MAX_TAIL_LENGTH = 10; \r\n\r\nexport function initializeWindLayer() {\r\n\twindCanvas = document.getElementById('wind-canvas') as HTMLCanvasElement;\r\n\tif (!windCanvas) {\r\n\t\tconsole.error(\"Wind canvas element not found!\");\r\n\t\treturn;\r\n\t}\r\n\twindCtx = windCanvas.getContext('2d');\r\n\tif (!windCtx) {\r\n\t\tconsole.error(\"Could not get 2D context from wind canvas!\");\r\n\t\treturn;\r\n\t}\r\n\t\r\n\tcreateWindParticles(10000, windParticles);\r\n\t\r\n\tconsole.log(\"Wind layer initialized with\", windParticles.length, \"particles\");\r\n}\r\n\r\nfunction createWindParticles(count: number, windParticles: WindParticle[]) {\r\n\tfor (let i = 0; i < count; i++) {\r\n\t\twindParticles.push({\r\n\t\t\tlocation: {\r\n\t\t\t\t// Global bounds: latitude -90 to 90, longitude -180 to 180\r\n\t\t\t\tlatitude: Math.random() * 180 - 90,\r\n\t\t\t\tlongitude: Math.random() * 360 - 180,\r\n\t\t\t},\r\n\t\t\tcurrent: {\r\n\t\t\t\ttemperature2m: 0,\r\n\t\t\t\twindSpeed10m: 0,\r\n\t\t\t\twindDirection10m: 0,\r\n\t\t\t},\r\n\t\t\tcomputed: {\r\n\t\t\t\topacity: 0.5,\r\n\t\t\t\tcolor: 'rgba(255, 255, 255, 0.5)',\r\n\t\t\t\ttail: []\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n\r\nexport function redrawWindParticles(elapsed: number) {\r\n\tif (!windCanvas || !windCtx) {\r\n\t\tconsole.warn(\"Wind canvas or context not initialized, skipping redraw.\");\r\n\t\treturn;\r\n\t}\r\n\r\n\tif (!weatherDataTree) {\r\n\t\tif (!window.hasLoggedMissingTree) {\r\n\t\t\tconsole.warn(\"Weather data tree not available, skipping wind particle redraw.\");\r\n\t\t\twindow.hasLoggedMissingTree = true;\r\n\t\t}\r\n\t\twindCtx.clearRect(0, 0, windCanvas.width, windCanvas.height);\r\n\t\treturn;\r\n\t}\r\n\r\n\tconst worldMap = document.querySelector('#world-map');\r\n\tif (!worldMap) return;\r\n\r\n\tconst mapRect = worldMap.getBoundingClientRect();\r\n\t// Check if dimensions changed before resizing and clearing - might save some work\r\n    if (windCanvas.width !== mapRect.width || windCanvas.height !== mapRect.height) {\r\n        windCanvas.width = mapRect.width;\r\n        windCanvas.height = mapRect.height;\r\n    }\r\n\twindCtx.clearRect(0, 0, windCanvas.width, windCanvas.height);\r\n\tconst converter = projection.createCoordinateConverter(windCanvas.width, windCanvas.height);\r\n\tconst scaledElapsed = elapsed * 15; // Scale time factor once\r\n\r\n    // --- Particle Respawning (outside the loop) ---\r\n    const numToRespaw = Math.floor(windParticles.length * PARTICLE_RESPAWN_FRACTION);\r\n    if (numToRespaw > 0) {\r\n        windParticles.splice(0, numToRespaw); // Remove oldest particles\r\n        createWindParticles(numToRespaw, windParticles); // Add new ones\r\n    }\r\n    // --- End Particle Respawning ---\r\n\r\n\r\n\twindParticles.forEach((particle) => {\r\n\r\n        // Calculate particle's current 3D position for KDTree search\r\n        const currentLatRad = particle.location.latitude * DEG_TO_RAD; // Use constant\r\n        const currentLonRad = particle.location.longitude * DEG_TO_RAD; // Use constant\r\n        const R = 1; // Unit sphere\r\n        particle.x = R * Math.cos(currentLatRad) * Math.cos(currentLonRad);\r\n        particle.y = R * Math.cos(currentLatRad) * Math.sin(currentLonRad);\r\n        particle.z = R * Math.sin(currentLatRad);\r\n\r\n        // Find nearest weather data point using the X,Y,Z based tree\r\n\t\tlet nearest = weatherDataTree!.nearest(particle, 1);\r\n        if (!nearest || nearest.length === 0) {\r\n            return; // Skip if no data found\r\n        }\r\n\t\tlet [point, distance] = nearest[0]; // point is a WeatherData object\r\n\r\n        // --- Update particle properties based on the nearest point ---\r\n        const blendFactor = 0.05; // Adjust for faster/slower adaptation\r\n        particle.current.windSpeed10m += (point.current.windSpeed10m - particle.current.windSpeed10m) * blendFactor;\r\n        \r\n        // Smoother angle interpolation (handle wrap-around)\r\n        let angleDiff = point.current.windDirection10m - particle.current.windDirection10m;\r\n        while (angleDiff <= -180) angleDiff += 360;\r\n        while (angleDiff > 180) angleDiff -= 360;\r\n        particle.current.windDirection10m += angleDiff * blendFactor;\r\n        particle.current.windDirection10m = (particle.current.windDirection10m + 360) % 360; \r\n\r\n\t\tparticle.computed.color = point.computed.color;\r\n\t\tparticle.computed.opacity = parseFloat(point.computed.opacity); // Ensure opacity is a number\r\n\r\n        // Convert wind speed (m/s) to approximate degrees latitude per ms\r\n        // Scaled elapsed time is used here\r\n        const speedDegPerMs = particle.current.windSpeed10m / 111000 * scaledElapsed; \r\n\r\n        // Convert meteorological wind direction to radians\r\n        const meteoDirectionRad = particle.current.windDirection10m * DEG_TO_RAD; // Use constant\r\n\r\n        // Calculate V (Northward) and U (Eastward) components in degrees/ms\r\n        const vComponentDeg = speedDegPerMs * (-Math.cos(meteoDirectionRad));\r\n        const uComponentDeg = speedDegPerMs * (Math.sin(meteoDirectionRad));\r\n\r\n        // Calculate displacement in degrees\r\n        const deltaLat = vComponentDeg;\r\n        const lonScale = Math.cos(currentLatRad);\r\n        const deltaLon = lonScale > 0.01 ? (uComponentDeg / lonScale) : 0;\r\n\r\n        // --- Store previous pixel location for tail ---\r\n        const prevPixelX = particle.computed.pixelX;\r\n        const prevPixelY = particle.computed.pixelY;\r\n\r\n        // Update particle location\r\n        particle.location.latitude += deltaLat;\r\n        particle.location.longitude += deltaLon;\r\n\r\n\t\t// Wrap around the planet\r\n\t\tlet wrapped = false;\r\n        if (particle.location.latitude > 90) {\r\n            particle.location.latitude = 180 - particle.location.latitude;\r\n            particle.location.longitude += 180;\r\n\t\t\twrapped = true;\r\n        } else if (particle.location.latitude < -90) {\r\n            particle.location.latitude = -180 - particle.location.latitude;\r\n            particle.location.longitude += 180;\r\n\t\t\twrapped = true;\r\n        }\r\n\t\tif (particle.location.longitude > 180) {\r\n\t\t\tparticle.location.longitude -= 360;\r\n\t\t\twrapped = true;\r\n\t\t} else if (particle.location.longitude < -180) {\r\n\t\t\tparticle.location.longitude += 360;\r\n\t\t\twrapped = true;\r\n\t\t}\r\n\r\n\t\t// --- Calculate new pixel position ONCE ---\r\n\t\tconst newPixelLocation = converter.geoToPixel(particle.location.latitude, particle.location.longitude);\r\n        particle.computed.pixelX = newPixelLocation.x;\r\n        particle.computed.pixelY = newPixelLocation.y;\r\n\r\n        // --- Tail Management ---\r\n        if (wrapped) {\r\n            particle.computed.tail = []; // Reset tail on wrap\r\n        } else {\r\n             // Add previous *geo* coords to tail - needed if map resizes\r\n            particle.computed.tail.push({\r\n                latitude: particle.location.latitude - deltaLat, // Approx previous geo\r\n                longitude: particle.location.longitude - deltaLon // Approx previous geo\r\n            });\r\n            if (particle.computed.tail.length > MAX_TAIL_LENGTH) {\r\n                particle.computed.tail.shift(); // Still using shift for now\r\n            }\r\n        }\r\n\r\n\t\t// --- Draw Tail ---\r\n        if (particle.computed.tail.length > 1 && !wrapped && prevPixelX !== undefined && prevPixelY !== undefined) {\r\n            windCtx!.beginPath();\r\n            windCtx!.moveTo(prevPixelX, prevPixelY); \r\n            windCtx!.lineTo(particle.computed.pixelX!, particle.computed.pixelY!); \r\n\r\n            for (let i = particle.computed.tail.length - 2; i >= 0; i--) {\r\n                const tailPixel = converter.geoToPixel(particle.computed.tail[i].latitude, particle.computed.tail[i].longitude);\r\n                windCtx!.lineTo(tailPixel.x, tailPixel.y);\r\n            }\r\n            \r\n            windCtx!.strokeStyle = particle.computed.color; \r\n            windCtx!.globalAlpha = 0.3; // Fainter tail\r\n            windCtx!.lineWidth = 1;\r\n            windCtx!.stroke();\r\n        }\r\n        \r\n\r\n\t\t// --- Draw Particle Head ---\r\n\t\tdrawDotOnCanvas(windCtx!, particle.computed.pixelX!, particle.computed.pixelY!, particle.computed.opacity, particle.computed.color);\r\n\r\n    });\r\n}\r\n\r\nfunction drawDotOnCanvas(ctx: CanvasRenderingContext2D, x: number, y: number, opacity: number, color: string) {\r\n\tctx.fillStyle = color;\r\n\tctx.globalAlpha = opacity;\r\n\t\r\n\tconst screenWidth = window.innerWidth;\r\n\tconst screenHeight = window.innerHeight;\r\n\tconst screenSize = Math.min(screenWidth, screenHeight);\r\n\t\r\n\tlet size = 1;\r\n\t\r\n\tif (screenSize >= 768) {\r\n\t\tsize = 3;\r\n\t} else if (screenSize >= 480) {\r\n\t\tsize = 2;\r\n\t}\r\n\r\n\tconst halfSize = size / 2;\r\n\t\r\n\tctx.fillRect(\r\n\t\tMath.floor(x - halfSize), \r\n\t\tMath.floor(y - halfSize), \r\n\t\tsize, \r\n\t\tsize\r\n\t);\r\n}\r\n\r\nexport function clearWindLayer() {\r\n\tif (windCtx && windCanvas) {\r\n\t\twindCtx.clearRect(0, 0, windCanvas.width, windCanvas.height);\r\n\t}\r\n\twindParticles = [];\r\n\tconsole.log(\"Wind layer cleared.\");\r\n}\r\n"],"names":["$4635365ae85fe8c7$var$resizeTimeout","factory","$2a714b91454b8405$exports","exports1","Node","obj","dimension","parent","left","right","BinaryHeap","scoreFunction","content","prototype","push","element","bubbleUp","length","pop","result","end","sinkDown","peek","remove","node","len","i","Error","size","n","parentN","Math","floor","elemScore","child2N","child1N","swap","child1","child1Score","child2","kdTree","points","metric","dimensions","self","Array","isArray","root","buildTree","depth","median","dim","sort","a","b","slice","restoreParent","toJSON","src","dest","insert","point","newNode","insertPosition","innerSearch","nodeSearch","removeNode","nextNode","nextObj","pDimension","findMin","own","min","nearest","maxNodes","maxDistance","bestNodes","e","nearestSearch","bestChild","linearDistance","otherChild","ownDistance","linearPoint","saveNode","distance","abs","balanceFactor","height","max","log","count","define","amd","$4635365ae85fe8c7$var$cachedSvgElement","$4635365ae85fe8c7$var$cachedScaleBarElement","$4635365ae85fe8c7$var$cachedScaleTextElement","$4635365ae85fe8c7$var$cachedConverter","$4635365ae85fe8c7$var$cachedMapWidth","$4635365ae85fe8c7$var$cachedMapHeight","$4635365ae85fe8c7$export$58834c9ab2105e58","width","console","projection","d3","geoMercator","scale","PI","translate","converter","pixelToGeo","x","y","longitude","latitude","invert","geoToPixel","$4635365ae85fe8c7$export$ce4840fad26380af","displayValue","displayUnit","document","querySelector","svg","scaleBar","scaleText","svgRect","getBoundingClientRect","mapWidth","mapHeight","realDistanceMeters","$4635365ae85fe8c7$var$calculateRealDistanceForPixelLength","barPixelLength","scaleBarY","geoStart","geoEnd","isNaN","warn","geoDistanceRadians","geoDistance","textContent","style","round","window","addEventListener","clearTimeout","setTimeout","event","svgX","clientX","svgY","clientY","top","geoCoords","toFixed","$25fa000d8b286cb3$var$windParticles","$25fa000d8b286cb3$var$windCanvas","$25fa000d8b286cb3$var$windCtx","$25fa000d8b286cb3$var$DEG_TO_RAD","$25fa000d8b286cb3$var$createWindParticles","windParticles","location","random","current","temperature2m","windSpeed10m","windDirection10m","computed","opacity","color","tail","$9791a722e428427e$var$loadWeatherDataFromFile","filePath","response","fetch","ok","error","status","statusText","cachedObject","json","data","$9791a722e428427e$export$38885f836d62c34e","$9791a722e428427e$var$canvas","$9791a722e428427e$var$ctx","$9791a722e428427e$export$722377996733fc7a","$9791a722e428427e$var$coordinateConverter","$9791a722e428427e$var$redrawAllArrows","worldMap","mapRect","clearRect","forEach","weatherData","pixelPos","$9791a722e428427e$var$drawArrowOnCanvas","ctx","rotationDegrees","angleRad","save","rotate","globalAlpha","strokeStyle","lineWidth","beginPath","moveTo","lineTo","stroke","restore","parseFloat","resizeTimer","$9791a722e428427e$var$setupTooltip","getElementById","getContext","$25fa000d8b286cb3$export$720755392c964ba5","staticDataPath","loadedData","latRad","lonRad","R","cos","sin","z","hasOwnProperty","lat1","lon1","lat2","lon2","latRad1","lonRad1","latRad2","lonRad2","dx","x1","dy","y1","dz","z1","sqrt","$9791a722e428427e$var$lastDataUpdateTime","Date","now","$9791a722e428427e$var$animateWindParticles","elapsed","$25fa000d8b286cb3$export$8c8495f743cb3cff","hasLoggedMissingTree","scaledElapsed","numToRespaw","splice","particle","currentLatRad","currentLonRad","angleDiff","speedDegPerMs","meteoDirectionRad","vComponentDeg","uComponentDeg","lonScale","deltaLon","prevPixelX","pixelX","prevPixelY","pixelY","wrapped","newPixelLocation","shift","undefined","tailPixel","$25fa000d8b286cb3$var$drawDotOnCanvas","fillStyle","screenSize","innerWidth","innerHeight","halfSize","fillRect","requestAnimationFrame","mapElement","innerHTML","tooltipElement","rect","target","mouseX","mouseY","display","nearestResult","nearestData","temp","wind","pageX","pageY"],"version":3,"file":"map.3c69c090.js.map"}
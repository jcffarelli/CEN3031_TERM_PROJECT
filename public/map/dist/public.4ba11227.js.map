{"mappings":"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","sources":["<anon>","src/public/js/particles.ts"],"sourcesContent":["\nfunction $parcel$export(e, n, v, s) {\n  Object.defineProperty(e, n, {get: v, set: s, enumerable: true, configurable: true});\n}\n\n      var $parcel$global = globalThis;\n    \nvar $parcel$modules = {};\nvar $parcel$inits = {};\n\nvar parcelRequire = $parcel$global[\"parcelRequire49ed\"];\n\nif (parcelRequire == null) {\n  parcelRequire = function(id) {\n    if (id in $parcel$modules) {\n      return $parcel$modules[id].exports;\n    }\n    if (id in $parcel$inits) {\n      var init = $parcel$inits[id];\n      delete $parcel$inits[id];\n      var module = {id: id, exports: {}};\n      $parcel$modules[id] = module;\n      init.call(module.exports, module, module.exports);\n      return module.exports;\n    }\n    var err = new Error(\"Cannot find module '\" + id + \"'\");\n    err.code = 'MODULE_NOT_FOUND';\n    throw err;\n  };\n\n  parcelRequire.register = function register(id, init) {\n    $parcel$inits[id] = init;\n  };\n\n  $parcel$global[\"parcelRequire49ed\"] = parcelRequire;\n}\n\nvar parcelRegister = parcelRequire.register;\nparcelRegister(\"kz4HC\", function(module, exports) {\n\n$parcel$export(module.exports, \"particleSystem\", () => $651366cd2670cfca$export$7eaafe3d5d6ffc22);\n\nvar $7YaLV = parcelRequire(\"7YaLV\");\nclass $651366cd2670cfca$var$ParticleSystem {\n    constructor(){\n        this.particles = [];\n        this.canvas = document.getElementById('particle-canvas');\n        this.setupCanvas();\n        this.engine = (0, $7YaLV.Engine).create({\n            gravity: {\n                x: 0,\n                y: 0,\n                scale: 0\n            }\n        });\n        this.world = this.engine.world;\n        this.render = (0, $7YaLV.Render).create({\n            canvas: this.canvas,\n            engine: this.engine,\n            options: {\n                width: window.innerWidth,\n                height: window.innerHeight,\n                wireframes: false,\n                background: 'transparent'\n            }\n        });\n        (0, $7YaLV.Events).on(this.engine, 'collisionStart', this.handleCollision.bind(this));\n        (0, $7YaLV.Render).run(this.render);\n        (0, $7YaLV.Engine).run(this.engine);\n    }\n    setupCanvas() {\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight;\n        this.canvas.style.position = 'absolute';\n        this.canvas.style.top = '0';\n        this.canvas.style.left = '0';\n        this.canvas.style.pointerEvents = 'none';\n    }\n    addParticle(x, y, windSpeed, windDirection, tempZScore, windSpeedZScore) {\n        // Base radius on wind speed z-score (bigger particles for more extreme winds)\n        const baseRadius = 3;\n        const radiusScale = Math.min(Math.max(Math.abs(windSpeedZScore), 0.5), 2);\n        const radius = baseRadius * radiusScale;\n        const particle = (0, $7YaLV.Bodies).circle(x, y, radius, {\n            friction: 0,\n            frictionAir: 0.02,\n            restitution: 0.8,\n            render: {\n                fillStyle: this.getColorFromZScore(tempZScore)\n            }\n        });\n        // Scale wind force based on z-score\n        const windForceScale = Math.min(Math.max(Math.abs(windSpeedZScore), 0.5), 2);\n        const windForce = {\n            x: Math.cos(windDirection * Math.PI / 180) * windSpeed * 0.001 * windForceScale,\n            y: Math.sin(windDirection * Math.PI / 180) * windSpeed * 0.001 * windForceScale\n        };\n        (0, $7YaLV.Body).setVelocity(particle, windForce);\n        const windParticle = {\n            body: particle,\n            windSpeed: windSpeed,\n            windDirection: windDirection,\n            temperature: tempZScore,\n            windSpeedZScore: windSpeedZScore\n        };\n        this.particles.push(windParticle);\n        (0, $7YaLV.World).add(this.world, particle);\n    }\n    handleCollision(event) {\n        event.pairs.forEach((pair)=>{\n            const particleA = this.particles.find((p)=>p.body.id === pair.bodyA.id);\n            const particleB = this.particles.find((p)=>p.body.id === pair.bodyB.id);\n            if (particleA && particleB) {\n                // Use z-scores to determine collision impact\n                const avgZScore = (Math.abs(particleA.windSpeedZScore) + Math.abs(particleB.windSpeedZScore)) / 2;\n                const force = Math.min(Math.max(avgZScore * 0.1, 0.05), 0.2);\n                (0, $7YaLV.Body).setVelocity(pair.bodyA, {\n                    x: pair.bodyA.velocity.x * (1 + force),\n                    y: pair.bodyA.velocity.y * (1 + force)\n                });\n                (0, $7YaLV.Body).setVelocity(pair.bodyB, {\n                    x: pair.bodyB.velocity.x * (1 + force),\n                    y: pair.bodyB.velocity.y * (1 + force)\n                });\n            }\n        });\n    }\n    getColorFromZScore(zScore) {\n        // Convert z-score to color\n        // Red for hot (positive z-scores), blue for cold (negative z-scores)\n        const intensity = Math.min(Math.max(Math.abs(zScore), 0.5), 2.5) / 2.5; // Normalize to 0.2-1 range\n        const alpha = 0.6 + intensity * 0.4; // Vary opacity based on intensity\n        if (zScore >= 0) {\n            // Hot temperatures: red to white\n            const value = Math.round(255 * (1 - intensity));\n            return `rgba(255, ${value}, ${value}, ${alpha})`;\n        } else {\n            // Cold temperatures: blue to white\n            const value = Math.round(255 * (1 - intensity));\n            return `rgba(${value}, ${value}, 255, ${alpha})`;\n        }\n    }\n    update() {\n        this.particles.forEach((particle)=>{\n            const pos = particle.body.position;\n            if (pos.x < 0 || pos.x > window.innerWidth || pos.y < 0 || pos.y > window.innerHeight) {\n                (0, $7YaLV.World).remove(this.world, particle.body);\n                this.particles = this.particles.filter((p)=>p.body.id !== particle.body.id);\n            }\n        });\n        // Get map dimensions\n        const worldMap = document.querySelector('#world-map');\n        if (!worldMap) return;\n        const mapRect = worldMap.getBoundingClientRect();\n        // Apply torus wrapping to each particle\n        this.particles.forEach((particle)=>{\n            const pos = particle.body.position;\n            const wrapped = this.handleTorusWrapping(pos.x, pos.y, mapRect.width, mapRect.height);\n            (0, $7YaLV.Body).setPosition(particle.body, wrapped);\n        });\n    }\n    clear() {\n        this.particles.forEach((particle)=>{\n            (0, $7YaLV.World).remove(this.world, particle.body);\n        });\n        this.particles = [];\n    }\n    handleTorusWrapping(x, y, mapWidth, mapHeight) {\n        let wrappedX = x;\n        let wrappedY = y;\n        // Wrap horizontally (longitude)\n        if (x < 0) wrappedX = mapWidth + x % mapWidth;\n        else if (x > mapWidth) wrappedX = x % mapWidth;\n        // Optional: Constrain vertical movement (latitude)\n        wrappedY = Math.max(0, Math.min(mapHeight, y));\n        return {\n            x: wrappedX,\n            y: wrappedY\n        };\n    }\n}\nconst $651366cd2670cfca$export$7eaafe3d5d6ffc22 = new $651366cd2670cfca$var$ParticleSystem();\n\n});\n\n\nparcelRequire(\"kz4HC\");\n\n//# sourceMappingURL=public.4ba11227.js.map\n","import { Engine, Render, World, Bodies, Body, Events } from 'matter-js';\r\n\r\ninterface WindParticle {\r\n    body: Matter.Body;\r\n    windSpeed: number;\r\n    windDirection: number;\r\n    temperature: number;\r\n    windSpeedZScore: number;\r\n}\r\n\r\nclass ParticleSystem {\r\n    private engine: Matter.Engine;\r\n    private render: Matter.Render;\r\n    private world: Matter.World;\r\n    private particles: WindParticle[] = [];\r\n    private canvas: HTMLCanvasElement;\r\n\r\n    constructor() {\r\n        this.canvas = document.getElementById('particle-canvas') as HTMLCanvasElement;\r\n        this.setupCanvas();\r\n        \r\n        this.engine = Engine.create({\r\n            gravity: { x: 0, y: 0, scale: 0 }\r\n        });\r\n        \r\n        this.world = this.engine.world;\r\n        \r\n        this.render = Render.create({\r\n            canvas: this.canvas,\r\n            engine: this.engine,\r\n            options: {\r\n                width: window.innerWidth,\r\n                height: window.innerHeight,\r\n                wireframes: false,\r\n                background: 'transparent'\r\n            }\r\n        });\r\n\r\n        Events.on(this.engine, 'collisionStart', this.handleCollision.bind(this));\r\n        \r\n        Render.run(this.render);\r\n        Engine.run(this.engine);\r\n    }\r\n\r\n    private setupCanvas() {\r\n        this.canvas.width = window.innerWidth;\r\n        this.canvas.height = window.innerHeight;\r\n        this.canvas.style.position = 'absolute';\r\n        this.canvas.style.top = '0';\r\n        this.canvas.style.left = '0';\r\n        this.canvas.style.pointerEvents = 'none';\r\n    }\r\n\r\n    public addParticle(x: number, y: number, windSpeed: number, windDirection: number, tempZScore: number, windSpeedZScore: number) {\r\n        // Base radius on wind speed z-score (bigger particles for more extreme winds)\r\n        const baseRadius = 3;\r\n        const radiusScale = Math.min(Math.max(Math.abs(windSpeedZScore), 0.5), 2);\r\n        const radius = baseRadius * radiusScale;\r\n\r\n        const particle = Bodies.circle(x, y, radius, {\r\n            friction: 0,\r\n            frictionAir: 0.02,\r\n            restitution: 0.8,\r\n            render: {\r\n                fillStyle: this.getColorFromZScore(tempZScore)\r\n            }\r\n        });\r\n\r\n        // Scale wind force based on z-score\r\n        const windForceScale = Math.min(Math.max(Math.abs(windSpeedZScore), 0.5), 2);\r\n        const windForce = {\r\n            x: Math.cos(windDirection * Math.PI / 180) * windSpeed * 0.001 * windForceScale,\r\n            y: Math.sin(windDirection * Math.PI / 180) * windSpeed * 0.001 * windForceScale\r\n        };\r\n\r\n        Body.setVelocity(particle, windForce);\r\n\r\n        const windParticle: WindParticle = {\r\n            body: particle,\r\n            windSpeed,\r\n            windDirection,\r\n            temperature: tempZScore,\r\n            windSpeedZScore\r\n        };\r\n\r\n        this.particles.push(windParticle);\r\n        World.add(this.world, particle);\r\n    }\r\n\r\n    private handleCollision(event: Matter.IEventCollision<Matter.Engine>) {\r\n        event.pairs.forEach(pair => {\r\n            const particleA = this.particles.find(p => p.body.id === pair.bodyA.id);\r\n            const particleB = this.particles.find(p => p.body.id === pair.bodyB.id);\r\n\r\n            if (particleA && particleB) {\r\n                // Use z-scores to determine collision impact\r\n                const avgZScore = (Math.abs(particleA.windSpeedZScore) + Math.abs(particleB.windSpeedZScore)) / 2;\r\n                const force = Math.min(Math.max(avgZScore * 0.1, 0.05), 0.2);\r\n\r\n                Body.setVelocity(pair.bodyA, {\r\n                    x: pair.bodyA.velocity.x * (1 + force),\r\n                    y: pair.bodyA.velocity.y * (1 + force)\r\n                });\r\n\r\n                Body.setVelocity(pair.bodyB, {\r\n                    x: pair.bodyB.velocity.x * (1 + force),\r\n                    y: pair.bodyB.velocity.y * (1 + force)\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    private getColorFromZScore(zScore: number): string {\r\n        // Convert z-score to color\r\n        // Red for hot (positive z-scores), blue for cold (negative z-scores)\r\n        const intensity = Math.min(Math.max(Math.abs(zScore), 0.5), 2.5) / 2.5; // Normalize to 0.2-1 range\r\n        const alpha = 0.6 + (intensity * 0.4); // Vary opacity based on intensity\r\n\r\n        if (zScore >= 0) {\r\n            // Hot temperatures: red to white\r\n            const value = Math.round(255 * (1 - intensity));\r\n            return `rgba(255, ${value}, ${value}, ${alpha})`;\r\n        } else {\r\n            // Cold temperatures: blue to white\r\n            const value = Math.round(255 * (1 - intensity));\r\n            return `rgba(${value}, ${value}, 255, ${alpha})`;\r\n        }\r\n    }\r\n\r\n    public update() {\r\n        this.particles.forEach(particle => {\r\n            const pos = particle.body.position;\r\n            if (pos.x < 0 || pos.x > window.innerWidth || pos.y < 0 || pos.y > window.innerHeight) {\r\n                World.remove(this.world, particle.body);\r\n                this.particles = this.particles.filter(p => p.body.id !== particle.body.id);\r\n            }\r\n        });\r\n\r\n        // Get map dimensions\r\n        const worldMap = document.querySelector('#world-map');\r\n        if (!worldMap) return;\r\n        const mapRect = worldMap.getBoundingClientRect();\r\n        \r\n        // Apply torus wrapping to each particle\r\n        this.particles.forEach(particle => {\r\n            const pos = particle.body.position;\r\n            const wrapped = this.handleTorusWrapping(pos.x, pos.y, mapRect.width, mapRect.height);\r\n            Body.setPosition(particle.body, wrapped);\r\n        });\r\n    }\r\n\r\n    public clear() {\r\n        this.particles.forEach(particle => {\r\n            World.remove(this.world, particle.body);\r\n        });\r\n        this.particles = [];\r\n    }\r\n\r\n    private handleTorusWrapping(x: number, y: number, mapWidth: number, mapHeight: number) {\r\n        let wrappedX = x;\r\n        let wrappedY = y;\r\n        \r\n        // Wrap horizontally (longitude)\r\n        if (x < 0) {\r\n            wrappedX = mapWidth + (x % mapWidth);\r\n        } else if (x > mapWidth) {\r\n            wrappedX = x % mapWidth;\r\n        }\r\n        \r\n        // Optional: Constrain vertical movement (latitude)\r\n        wrappedY = Math.max(0, Math.min(mapHeight, y));\r\n        \r\n        return { x: wrappedX, y: wrappedY };\r\n    }\r\n}\r\n\r\nexport const particleSystem = new ParticleSystem(); "],"names":["$parcel$global","globalThis","$parcel$modules","$parcel$inits","parcelRequire","id","exports","init","module","call","err","Error","code","register","parcelRegister","Object","defineProperty","get","$651366cd2670cfca$export$7eaafe3d5d6ffc22","set","s","enumerable","configurable","$7YaLV","constructor","particles","canvas","document","getElementById","setupCanvas","engine","Engine","create","gravity","x","y","scale","world","render","Render","options","width","window","innerWidth","height","innerHeight","wireframes","background","Events","on","handleCollision","bind","run","style","position","top","left","pointerEvents","addParticle","windSpeed","windDirection","tempZScore","windSpeedZScore","radiusScale","Math","min","max","abs","particle","Bodies","circle","baseRadius","friction","frictionAir","restitution","fillStyle","getColorFromZScore","windForceScale","windForce","cos","PI","sin","Body","setVelocity","push","body","temperature","World","add","event","pairs","forEach","pair","particleA","find","p","bodyA","particleB","bodyB","force","avgZScore","velocity","zScore","intensity","alpha","value","round","update","pos","remove","filter","worldMap","querySelector","mapRect","getBoundingClientRect","wrapped","handleTorusWrapping","setPosition","clear","mapWidth","mapHeight","wrappedX","wrappedY"],"version":3,"file":"public.4ba11227.js.map"}